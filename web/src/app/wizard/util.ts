import { DateTime, DurationLike } from 'luxon'
import { WizardFormValue } from './WizardForm'
import {
  CreateEscalationPolicyInput,
  CreateRotationInput,
  CreateScheduleInput,
  CreateServiceInput,
  IntegrationKeyType,
  RotationType,
  ScheduleTargetInput,
} from '../../schema'

const DESC = 'Generated by Setup Wizard'
const CHAR_LIMIT = 64
const SECONDARY_CHAR_COUNT = 10
const FTS_CHAR_COUNT = 4

export function getService(value: WizardFormValue): CreateServiceInput {
  return {
    name: value.teamName,
    description: DESC,
    newIntegrationKeys: [
      {
        type: value.key?.value as IntegrationKeyType,
        name: value.key?.label + ' Integration Key',
      },
    ],
    favorite: true,
  }
}

export function getEscalationPolicy(
  value: WizardFormValue,
): CreateEscalationPolicyInput {
  return {
    name: value.teamName,
    description: DESC,
    repeat: Number(value.repeat),
  }
}

export function getSchedule(
  key: string,
  value: WizardFormValue,
  secondary: boolean,
): CreateScheduleInput {
  const s = secondary ? value.secondarySchedule : value.primarySchedule
  let name = value.teamName

  if (secondary) {
    name = key.includes('primary') ? name + ' Primary' : name + ' Secondary'
  }

  return {
    name,
    description: DESC,
    timeZone: s.timeZone || '',
    favorite: true,
  }
}

/*
 * Generates the variables for the targets
 * to be used while creating a new schedule
 */
export function getScheduleTargets(
  key: string,
  value: WizardFormValue,
  secondary: boolean,
): ScheduleTargetInput[] {
  const s = secondary ? value.secondarySchedule : value.primarySchedule
  const targets = [] as ScheduleTargetInput[]
  const fts = s.followTheSunRotation.enable === 'yes'

  // return just the users as schedule targets if rotation type is set to "never"
  if (s.rotation.type === 'never') {
    return s.users.map((id) => ({
      target: {
        id,
        type: 'user',
      },
      rules: [{}], // always active
    }))
  }

  // reusable target fn for rotation targets (normal/follow the sun)
  const type = s.rotation.type
  const duration =
    type === 'daily' ? { day: 1 } : type === 'weekly' ? { week: 1 } : null

  const target = (isFTS: boolean): CreateRotationInput => {
    let tzText = isFTS ? s.followTheSunRotation.timeZone : ''
    if (isFTS && s.followTheSunRotation.timeZone === s.timeZone) {
      tzText = tzText + ' FTS'
    }

    const name =
      value.teamName +
      (secondary ? (key.includes('primary') ? ' Primary' : ' Secondary') : '') +
      (tzText ? ` ${tzText}` : '')

    const getErrMsg = (): number => {
      const timeZoneLength = isFTS
        ? s.followTheSunRotation?.timeZone?.length
        : 0
      const timeZoneMatch =
        isFTS && s.followTheSunRotation?.timeZone === s.timeZone
          ? FTS_CHAR_COUNT
          : 0
      const secondaryCharCount = secondary ? SECONDARY_CHAR_COUNT : 0

      const remainingChars =
        CHAR_LIMIT - secondaryCharCount - (timeZoneLength || 0) - timeZoneMatch

      throw new Error(`cannot be more than ${remainingChars} characters`)
    }

    // name length validation
    if (name.length > CHAR_LIMIT) {
      throw getErrMsg()
    }

    const getTimeZone = (): string => {
      if (isFTS) return s.followTheSunRotation.timeZone as string
      return s.timeZone as string
    }

    return {
      name: name.replace(/\//g, '-'),
      description: DESC,
      timeZone: getTimeZone(),
      start: DateTime.fromISO(s.rotation?.startDate as string)
        .minus(duration as DurationLike)
        .toISO(),
      type: s.rotation.type as RotationType,
      userIDs: isFTS ? s.followTheSunRotation.users : s.users,
    }
  }

  // add first rotation
  targets.push({
    newRotation: target(false),
    rules: fts ? [{ start: '09:00', end: '21:00' }] : [{}],
  })

  // push a second rotation for "follow the sun", if enabled
  if (fts) {
    targets.push({
      newRotation: target(true),
      rules: [{ start: '21:00', end: '09:00' }],
    })
  }

  return targets
}
