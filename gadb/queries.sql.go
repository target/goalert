// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package gadb

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const aPIKeyAuthCheck = `-- name: APIKeyAuthCheck :one
SELECT
    TRUE
FROM
    gql_api_keys
WHERE
    gql_api_keys.id = $1
    AND gql_api_keys.deleted_at IS NULL
    AND gql_api_keys.expires_at > now()
`

func (q *Queries) APIKeyAuthCheck(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, aPIKeyAuthCheck, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const aPIKeyAuthPolicy = `-- name: APIKeyAuthPolicy :one
SELECT
    gql_api_keys.policy
FROM
    gql_api_keys
WHERE
    gql_api_keys.id = $1
    AND gql_api_keys.deleted_at IS NULL
    AND gql_api_keys.expires_at > now()
`

// APIKeyAuth returns the API key policy with the given id, if it exists and is not expired.
func (q *Queries) APIKeyAuthPolicy(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, aPIKeyAuthPolicy, id)
	var policy json.RawMessage
	err := row.Scan(&policy)
	return policy, err
}

const aPIKeyDelete = `-- name: APIKeyDelete :exec
UPDATE
    gql_api_keys
SET
    deleted_at = now(),
    deleted_by = $2
WHERE
    id = $1
`

type APIKeyDeleteParams struct {
	ID        uuid.UUID
	DeletedBy uuid.NullUUID
}

func (q *Queries) APIKeyDelete(ctx context.Context, arg APIKeyDeleteParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyDelete, arg.ID, arg.DeletedBy)
	return err
}

const aPIKeyForUpdate = `-- name: APIKeyForUpdate :one
SELECT
    name,
    description
FROM
    gql_api_keys
WHERE
    id = $1
    AND deleted_at IS NULL
FOR UPDATE
`

type APIKeyForUpdateRow struct {
	Name        string
	Description string
}

func (q *Queries) APIKeyForUpdate(ctx context.Context, id uuid.UUID) (APIKeyForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, aPIKeyForUpdate, id)
	var i APIKeyForUpdateRow
	err := row.Scan(&i.Name, &i.Description)
	return i, err
}

const aPIKeyInsert = `-- name: APIKeyInsert :exec
INSERT INTO gql_api_keys(id, name, description, POLICY, created_by, updated_by, expires_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type APIKeyInsertParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	Policy      json.RawMessage
	CreatedBy   uuid.NullUUID
	UpdatedBy   uuid.NullUUID
	ExpiresAt   time.Time
}

func (q *Queries) APIKeyInsert(ctx context.Context, arg APIKeyInsertParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyInsert,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Policy,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.ExpiresAt,
	)
	return err
}

const aPIKeyList = `-- name: APIKeyList :many
SELECT
    gql_api_keys.created_at, gql_api_keys.created_by, gql_api_keys.deleted_at, gql_api_keys.deleted_by, gql_api_keys.description, gql_api_keys.expires_at, gql_api_keys.id, gql_api_keys.name, gql_api_keys.policy, gql_api_keys.updated_at, gql_api_keys.updated_by,
    gql_api_key_usage.used_at AS last_used_at,
    gql_api_key_usage.user_agent AS last_user_agent,
    gql_api_key_usage.ip_address AS last_ip_address
FROM
    gql_api_keys
    LEFT JOIN gql_api_key_usage ON gql_api_keys.id = gql_api_key_usage.api_key_id
WHERE
    gql_api_keys.deleted_at IS NULL
`

type APIKeyListRow struct {
	CreatedAt     time.Time
	CreatedBy     uuid.NullUUID
	DeletedAt     sql.NullTime
	DeletedBy     uuid.NullUUID
	Description   string
	ExpiresAt     time.Time
	ID            uuid.UUID
	Name          string
	Policy        json.RawMessage
	UpdatedAt     time.Time
	UpdatedBy     uuid.NullUUID
	LastUsedAt    sql.NullTime
	LastUserAgent sql.NullString
	LastIpAddress pqtype.Inet
}

// APIKeyList returns all API keys, along with the last time they were used.
func (q *Queries) APIKeyList(ctx context.Context) ([]APIKeyListRow, error) {
	rows, err := q.db.QueryContext(ctx, aPIKeyList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []APIKeyListRow
	for rows.Next() {
		var i APIKeyListRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.CreatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.Description,
			&i.ExpiresAt,
			&i.ID,
			&i.Name,
			&i.Policy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.LastUsedAt,
			&i.LastUserAgent,
			&i.LastIpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aPIKeyRecordUsage = `-- name: APIKeyRecordUsage :exec
INSERT INTO gql_api_key_usage(api_key_id, user_agent, ip_address)
    VALUES ($1::uuid, $2::text, $3::inet)
ON CONFLICT (api_key_id)
    DO UPDATE SET
        used_at = now(), user_agent = $2::text, ip_address = $3::inet
`

type APIKeyRecordUsageParams struct {
	KeyID     uuid.UUID
	UserAgent string
	IpAddress pqtype.Inet
}

// APIKeyRecordUsage records the usage of an API key.
func (q *Queries) APIKeyRecordUsage(ctx context.Context, arg APIKeyRecordUsageParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyRecordUsage, arg.KeyID, arg.UserAgent, arg.IpAddress)
	return err
}

const aPIKeyUpdate = `-- name: APIKeyUpdate :exec
UPDATE
    gql_api_keys
SET
    name = $2,
    description = $3,
    updated_at = now(),
    updated_by = $4
WHERE
    id = $1
`

type APIKeyUpdateParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	UpdatedBy   uuid.NullUUID
}

func (q *Queries) APIKeyUpdate(ctx context.Context, arg APIKeyUpdateParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyUpdate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedBy,
	)
	return err
}

const alertFeedback = `-- name: AlertFeedback :many
SELECT
    alert_id,
    noise_reason
FROM
    alert_feedback
WHERE
    alert_id = ANY ($1::int[])
`

type AlertFeedbackRow struct {
	AlertID     int64
	NoiseReason string
}

func (q *Queries) AlertFeedback(ctx context.Context, dollar_1 []int32) ([]AlertFeedbackRow, error) {
	rows, err := q.db.QueryContext(ctx, alertFeedback, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertFeedbackRow
	for rows.Next() {
		var i AlertFeedbackRow
		if err := rows.Scan(&i.AlertID, &i.NoiseReason); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const alertHasEPState = `-- name: AlertHasEPState :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            escalation_policy_state
        WHERE
            alert_id = $1) AS has_ep_state
`

func (q *Queries) AlertHasEPState(ctx context.Context, alertID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, alertHasEPState, alertID)
	var has_ep_state bool
	err := row.Scan(&has_ep_state)
	return has_ep_state, err
}

const alertLogHBIntervalMinutes = `-- name: AlertLogHBIntervalMinutes :one
SELECT
    (EXTRACT(EPOCH FROM heartbeat_interval) / 60)::int
FROM
    heartbeat_monitors
WHERE
    id = $1
`

func (q *Queries) AlertLogHBIntervalMinutes(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, alertLogHBIntervalMinutes, id)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const alertLogInsertEP = `-- name: AlertLogInsertEP :exec
INSERT INTO alert_logs(alert_id, event, sub_type, sub_user_id, sub_integration_key_id, sub_hb_monitor_id, sub_channel_id, sub_classifier, meta, message)
SELECT
    a.id,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
FROM
    alerts a
    JOIN services svc ON svc.id = a.service_id
        AND svc.escalation_policy_id = $1
WHERE
    a.status != 'closed'
`

type AlertLogInsertEPParams struct {
	EscalationPolicyID  uuid.UUID
	Event               EnumAlertLogEvent
	SubType             NullEnumAlertLogSubjectType
	SubUserID           uuid.NullUUID
	SubIntegrationKeyID uuid.NullUUID
	SubHbMonitorID      uuid.NullUUID
	SubChannelID        uuid.NullUUID
	SubClassifier       string
	Meta                pqtype.NullRawMessage
	Message             string
}

func (q *Queries) AlertLogInsertEP(ctx context.Context, arg AlertLogInsertEPParams) error {
	_, err := q.db.ExecContext(ctx, alertLogInsertEP,
		arg.EscalationPolicyID,
		arg.Event,
		arg.SubType,
		arg.SubUserID,
		arg.SubIntegrationKeyID,
		arg.SubHbMonitorID,
		arg.SubChannelID,
		arg.SubClassifier,
		arg.Meta,
		arg.Message,
	)
	return err
}

const alertLogInsertMany = `-- name: AlertLogInsertMany :exec
INSERT INTO alert_logs(alert_id, event, sub_type, sub_user_id, sub_integration_key_id, sub_hb_monitor_id, sub_channel_id, sub_classifier, meta, message)
SELECT
    unnest,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
FROM
    unnest($1::bigint[])
`

type AlertLogInsertManyParams struct {
	Column1             []int64
	Event               EnumAlertLogEvent
	SubType             NullEnumAlertLogSubjectType
	SubUserID           uuid.NullUUID
	SubIntegrationKeyID uuid.NullUUID
	SubHbMonitorID      uuid.NullUUID
	SubChannelID        uuid.NullUUID
	SubClassifier       string
	Meta                pqtype.NullRawMessage
	Message             string
}

func (q *Queries) AlertLogInsertMany(ctx context.Context, arg AlertLogInsertManyParams) error {
	_, err := q.db.ExecContext(ctx, alertLogInsertMany,
		pq.Array(arg.Column1),
		arg.Event,
		arg.SubType,
		arg.SubUserID,
		arg.SubIntegrationKeyID,
		arg.SubHbMonitorID,
		arg.SubChannelID,
		arg.SubClassifier,
		arg.Meta,
		arg.Message,
	)
	return err
}

const alertLogInsertSvc = `-- name: AlertLogInsertSvc :exec
INSERT INTO alert_logs(alert_id, event, sub_type, sub_user_id, sub_integration_key_id, sub_hb_monitor_id, sub_channel_id, sub_classifier, meta, message)
SELECT
    a.id,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
FROM
    alerts a
WHERE
    a.service_id = $1
    AND (($2 = 'closed'::enum_alert_log_event
            AND a.status != 'closed')
        OR ($2::enum_alert_log_event IN ('acknowledged', 'notification_sent')
            AND a.status = 'triggered'))
`

type AlertLogInsertSvcParams struct {
	ServiceID           uuid.NullUUID
	Event               EnumAlertLogEvent
	SubType             NullEnumAlertLogSubjectType
	SubUserID           uuid.NullUUID
	SubIntegrationKeyID uuid.NullUUID
	SubHbMonitorID      uuid.NullUUID
	SubChannelID        uuid.NullUUID
	SubClassifier       string
	Meta                pqtype.NullRawMessage
	Message             string
}

func (q *Queries) AlertLogInsertSvc(ctx context.Context, arg AlertLogInsertSvcParams) error {
	_, err := q.db.ExecContext(ctx, alertLogInsertSvc,
		arg.ServiceID,
		arg.Event,
		arg.SubType,
		arg.SubUserID,
		arg.SubIntegrationKeyID,
		arg.SubHbMonitorID,
		arg.SubChannelID,
		arg.SubClassifier,
		arg.Meta,
		arg.Message,
	)
	return err
}

const alertLogLookupCMType = `-- name: AlertLogLookupCMType :one
SELECT
    "type" AS cm_type
FROM
    user_contact_methods
WHERE
    id = $1
`

func (q *Queries) AlertLogLookupCMType(ctx context.Context, id uuid.UUID) (EnumUserContactMethodType, error) {
	row := q.db.QueryRowContext(ctx, alertLogLookupCMType, id)
	var cm_type EnumUserContactMethodType
	err := row.Scan(&cm_type)
	return cm_type, err
}

const alertManyMetadata = `-- name: AlertManyMetadata :many
SELECT
    alert_id,
    metadata
FROM
    alert_data
WHERE
    alert_id = ANY ($1::bigint[])
`

type AlertManyMetadataRow struct {
	AlertID  int64
	Metadata pqtype.NullRawMessage
}

func (q *Queries) AlertManyMetadata(ctx context.Context, alertIds []int64) ([]AlertManyMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, alertManyMetadata, pq.Array(alertIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertManyMetadataRow
	for rows.Next() {
		var i AlertManyMetadataRow
		if err := rows.Scan(&i.AlertID, &i.Metadata); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const alertMetadata = `-- name: AlertMetadata :one
SELECT
    metadata
FROM
    alert_data
WHERE
    alert_id = $1
`

func (q *Queries) AlertMetadata(ctx context.Context, alertID int64) (pqtype.NullRawMessage, error) {
	row := q.db.QueryRowContext(ctx, alertMetadata, alertID)
	var metadata pqtype.NullRawMessage
	err := row.Scan(&metadata)
	return metadata, err
}

const alertSetMetadata = `-- name: AlertSetMetadata :execrows
INSERT INTO alert_data(alert_id, metadata)
SELECT
    a.id,
    $2
FROM
    alerts a
WHERE
    a.id = $1
    AND a.status != 'closed'
    AND (a.service_id = $3
        OR $3 IS NULL) -- ensure the alert is associated with the service, if coming from an integration
ON CONFLICT (alert_id)
    DO UPDATE SET
        metadata = $2
    WHERE
        alert_data.alert_id = $1
`

type AlertSetMetadataParams struct {
	ID        int64
	Metadata  pqtype.NullRawMessage
	ServiceID uuid.NullUUID
}

func (q *Queries) AlertSetMetadata(ctx context.Context, arg AlertSetMetadataParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, alertSetMetadata, arg.ID, arg.Metadata, arg.ServiceID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const allPendingMsgDests = `-- name: AllPendingMsgDests :many
SELECT DISTINCT
    usr.name AS user_name,
    cm.type AS cm_type,
    nc.name AS nc_name,
    nc.type AS nc_type
FROM
    outgoing_messages om
    LEFT JOIN users usr ON usr.id = om.user_id
    LEFT JOIN notification_channels nc ON nc.id = om.channel_id
    LEFT JOIN user_contact_methods cm ON cm.id = om.contact_method_id
WHERE
    om.last_status = 'pending'
    AND (now() - om.created_at) > INTERVAL '15 seconds'
    AND (om.alert_id = $1::bigint
        OR (om.message_type = 'alert_notification_bundle'
            AND om.service_id = $2::uuid))
`

type AllPendingMsgDestsParams struct {
	AlertID   int64
	ServiceID uuid.UUID
}

type AllPendingMsgDestsRow struct {
	UserName sql.NullString
	CmType   NullEnumUserContactMethodType
	NcName   sql.NullString
	NcType   NullEnumNotifChannelType
}

func (q *Queries) AllPendingMsgDests(ctx context.Context, arg AllPendingMsgDestsParams) ([]AllPendingMsgDestsRow, error) {
	rows, err := q.db.QueryContext(ctx, allPendingMsgDests, arg.AlertID, arg.ServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllPendingMsgDestsRow
	for rows.Next() {
		var i AllPendingMsgDestsRow
		if err := rows.Scan(
			&i.UserName,
			&i.CmType,
			&i.NcName,
			&i.NcType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authLinkAddAuthSubject = `-- name: AuthLinkAddAuthSubject :exec
INSERT INTO auth_subjects(provider_id, subject_id, user_id)
    VALUES ($1, $2, $3)
`

type AuthLinkAddAuthSubjectParams struct {
	ProviderID string
	SubjectID  string
	UserID     uuid.UUID
}

func (q *Queries) AuthLinkAddAuthSubject(ctx context.Context, arg AuthLinkAddAuthSubjectParams) error {
	_, err := q.db.ExecContext(ctx, authLinkAddAuthSubject, arg.ProviderID, arg.SubjectID, arg.UserID)
	return err
}

const authLinkAddReq = `-- name: AuthLinkAddReq :exec
INSERT INTO auth_link_requests(id, provider_id, subject_id, expires_at, metadata)
    VALUES ($1, $2, $3, $4, $5)
`

type AuthLinkAddReqParams struct {
	ID         uuid.UUID
	ProviderID string
	SubjectID  string
	ExpiresAt  time.Time
	Metadata   json.RawMessage
}

func (q *Queries) AuthLinkAddReq(ctx context.Context, arg AuthLinkAddReqParams) error {
	_, err := q.db.ExecContext(ctx, authLinkAddReq,
		arg.ID,
		arg.ProviderID,
		arg.SubjectID,
		arg.ExpiresAt,
		arg.Metadata,
	)
	return err
}

const authLinkMetadata = `-- name: AuthLinkMetadata :one
SELECT
    metadata
FROM
    auth_link_requests
WHERE
    id = $1
    AND expires_at > now()
`

func (q *Queries) AuthLinkMetadata(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, authLinkMetadata, id)
	var metadata json.RawMessage
	err := row.Scan(&metadata)
	return metadata, err
}

const authLinkUseReq = `-- name: AuthLinkUseReq :one
DELETE FROM auth_link_requests
WHERE id = $1
    AND expires_at > now()
RETURNING
    provider_id,
    subject_id
`

type AuthLinkUseReqRow struct {
	ProviderID string
	SubjectID  string
}

func (q *Queries) AuthLinkUseReq(ctx context.Context, id uuid.UUID) (AuthLinkUseReqRow, error) {
	row := q.db.QueryRowContext(ctx, authLinkUseReq, id)
	var i AuthLinkUseReqRow
	err := row.Scan(&i.ProviderID, &i.SubjectID)
	return i, err
}

const calSubAuthUser = `-- name: CalSubAuthUser :one
UPDATE
    user_calendar_subscriptions
SET
    last_access = now()
WHERE
    NOT disabled
    AND id = $1
    AND date_trunc('second', created_at) = $2
RETURNING
    user_id
`

type CalSubAuthUserParams struct {
	ID        uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CalSubAuthUser(ctx context.Context, arg CalSubAuthUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, calSubAuthUser, arg.ID, arg.CreatedAt)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const calSubRenderInfo = `-- name: CalSubRenderInfo :one
SELECT
    now()::timestamptz AS now,
    sub.schedule_id,
    sched.name AS schedule_name,
    sub.config,
    sub.user_id
FROM
    user_calendar_subscriptions sub
    JOIN schedules sched ON sched.id = schedule_id
WHERE
    sub.id = $1
`

type CalSubRenderInfoRow struct {
	Now          time.Time
	ScheduleID   uuid.UUID
	ScheduleName string
	Config       json.RawMessage
	UserID       uuid.UUID
}

func (q *Queries) CalSubRenderInfo(ctx context.Context, id uuid.UUID) (CalSubRenderInfoRow, error) {
	row := q.db.QueryRowContext(ctx, calSubRenderInfo, id)
	var i CalSubRenderInfoRow
	err := row.Scan(
		&i.Now,
		&i.ScheduleID,
		&i.ScheduleName,
		&i.Config,
		&i.UserID,
	)
	return i, err
}

const calSubUserNames = `-- name: CalSubUserNames :many
SELECT
    id,
    name
FROM
    users
WHERE
    id = ANY ($1::uuid[])
`

type CalSubUserNamesRow struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CalSubUserNames(ctx context.Context, dollar_1 []uuid.UUID) ([]CalSubUserNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, calSubUserNames, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CalSubUserNamesRow
	for rows.Next() {
		var i CalSubUserNamesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodAdd = `-- name: ContactMethodAdd :exec
INSERT INTO user_contact_methods(id, name, type, value, disabled, user_id, enable_status_updates)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type ContactMethodAddParams struct {
	ID                  uuid.UUID
	Name                string
	Type                EnumUserContactMethodType
	Value               string
	Disabled            bool
	UserID              uuid.UUID
	EnableStatusUpdates bool
}

func (q *Queries) ContactMethodAdd(ctx context.Context, arg ContactMethodAddParams) error {
	_, err := q.db.ExecContext(ctx, contactMethodAdd,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Value,
		arg.Disabled,
		arg.UserID,
		arg.EnableStatusUpdates,
	)
	return err
}

const contactMethodDisable = `-- name: ContactMethodDisable :one
UPDATE
    user_contact_methods
SET
    disabled = TRUE
WHERE
    type = $1
    AND value = $2
RETURNING
    id
`

type ContactMethodDisableParams struct {
	Type  EnumUserContactMethodType
	Value string
}

func (q *Queries) ContactMethodDisable(ctx context.Context, arg ContactMethodDisableParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, contactMethodDisable, arg.Type, arg.Value)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const contactMethodEnable = `-- name: ContactMethodEnable :one
UPDATE
    user_contact_methods
SET
    disabled = FALSE
WHERE
    type = $1
    AND value = $2
RETURNING
    id
`

type ContactMethodEnableParams struct {
	Type  EnumUserContactMethodType
	Value string
}

func (q *Queries) ContactMethodEnable(ctx context.Context, arg ContactMethodEnableParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, contactMethodEnable, arg.Type, arg.Value)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const contactMethodFindAll = `-- name: ContactMethodFindAll :many
SELECT
    id,
    name,
    type,
    value,
    disabled,
    user_id,
    last_test_verify_at,
    enable_status_updates,
    pending
FROM
    user_contact_methods
WHERE
    user_id = $1
`

type ContactMethodFindAllRow struct {
	ID                  uuid.UUID
	Name                string
	Type                EnumUserContactMethodType
	Value               string
	Disabled            bool
	UserID              uuid.UUID
	LastTestVerifyAt    sql.NullTime
	EnableStatusUpdates bool
	Pending             bool
}

func (q *Queries) ContactMethodFindAll(ctx context.Context, userID uuid.UUID) ([]ContactMethodFindAllRow, error) {
	rows, err := q.db.QueryContext(ctx, contactMethodFindAll, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactMethodFindAllRow
	for rows.Next() {
		var i ContactMethodFindAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Disabled,
			&i.UserID,
			&i.LastTestVerifyAt,
			&i.EnableStatusUpdates,
			&i.Pending,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodFindMany = `-- name: ContactMethodFindMany :many
SELECT
    id,
    name,
    type,
    value,
    disabled,
    user_id,
    last_test_verify_at,
    enable_status_updates,
    pending
FROM
    user_contact_methods
WHERE
    id = ANY ($1::uuid[])
`

type ContactMethodFindManyRow struct {
	ID                  uuid.UUID
	Name                string
	Type                EnumUserContactMethodType
	Value               string
	Disabled            bool
	UserID              uuid.UUID
	LastTestVerifyAt    sql.NullTime
	EnableStatusUpdates bool
	Pending             bool
}

func (q *Queries) ContactMethodFindMany(ctx context.Context, dollar_1 []uuid.UUID) ([]ContactMethodFindManyRow, error) {
	rows, err := q.db.QueryContext(ctx, contactMethodFindMany, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ContactMethodFindManyRow
	for rows.Next() {
		var i ContactMethodFindManyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Disabled,
			&i.UserID,
			&i.LastTestVerifyAt,
			&i.EnableStatusUpdates,
			&i.Pending,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodFindOneUpdate = `-- name: ContactMethodFindOneUpdate :one
SELECT
    id,
    name,
    type,
    value,
    disabled,
    user_id,
    last_test_verify_at,
    enable_status_updates,
    pending
FROM
    user_contact_methods
WHERE
    id = $1
FOR UPDATE
`

type ContactMethodFindOneUpdateRow struct {
	ID                  uuid.UUID
	Name                string
	Type                EnumUserContactMethodType
	Value               string
	Disabled            bool
	UserID              uuid.UUID
	LastTestVerifyAt    sql.NullTime
	EnableStatusUpdates bool
	Pending             bool
}

func (q *Queries) ContactMethodFindOneUpdate(ctx context.Context, id uuid.UUID) (ContactMethodFindOneUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, contactMethodFindOneUpdate, id)
	var i ContactMethodFindOneUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.Disabled,
		&i.UserID,
		&i.LastTestVerifyAt,
		&i.EnableStatusUpdates,
		&i.Pending,
	)
	return i, err
}

const contactMethodFineOne = `-- name: ContactMethodFineOne :one
SELECT
    id,
    name,
    type,
    value,
    disabled,
    user_id,
    last_test_verify_at,
    enable_status_updates,
    pending
FROM
    user_contact_methods
WHERE
    id = $1
`

type ContactMethodFineOneRow struct {
	ID                  uuid.UUID
	Name                string
	Type                EnumUserContactMethodType
	Value               string
	Disabled            bool
	UserID              uuid.UUID
	LastTestVerifyAt    sql.NullTime
	EnableStatusUpdates bool
	Pending             bool
}

func (q *Queries) ContactMethodFineOne(ctx context.Context, id uuid.UUID) (ContactMethodFineOneRow, error) {
	row := q.db.QueryRowContext(ctx, contactMethodFineOne, id)
	var i ContactMethodFineOneRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Value,
		&i.Disabled,
		&i.UserID,
		&i.LastTestVerifyAt,
		&i.EnableStatusUpdates,
		&i.Pending,
	)
	return i, err
}

const contactMethodLookupUserID = `-- name: ContactMethodLookupUserID :many
SELECT DISTINCT
    user_id
FROM
    user_contact_methods
WHERE
    id = ANY ($1::uuid[])
`

func (q *Queries) ContactMethodLookupUserID(ctx context.Context, dollar_1 []uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, contactMethodLookupUserID, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodMetaTV = `-- name: ContactMethodMetaTV :one
SELECT
    coalesce(metadata, '{}'),
    now()::timestamptz AS now
FROM
    user_contact_methods
WHERE
    type = $1
    AND value = $2
`

type ContactMethodMetaTVParams struct {
	Type  EnumUserContactMethodType
	Value string
}

type ContactMethodMetaTVRow struct {
	Metadata json.RawMessage
	Now      time.Time
}

func (q *Queries) ContactMethodMetaTV(ctx context.Context, arg ContactMethodMetaTVParams) (ContactMethodMetaTVRow, error) {
	row := q.db.QueryRowContext(ctx, contactMethodMetaTV, arg.Type, arg.Value)
	var i ContactMethodMetaTVRow
	err := row.Scan(&i.Metadata, &i.Now)
	return i, err
}

const contactMethodUpdate = `-- name: ContactMethodUpdate :exec
UPDATE
    user_contact_methods
SET
    name = $2,
    disabled = $3,
    enable_status_updates = $4
WHERE
    id = $1
`

type ContactMethodUpdateParams struct {
	ID                  uuid.UUID
	Name                string
	Disabled            bool
	EnableStatusUpdates bool
}

func (q *Queries) ContactMethodUpdate(ctx context.Context, arg ContactMethodUpdateParams) error {
	_, err := q.db.ExecContext(ctx, contactMethodUpdate,
		arg.ID,
		arg.Name,
		arg.Disabled,
		arg.EnableStatusUpdates,
	)
	return err
}

const contactMethodUpdateMetaTV = `-- name: ContactMethodUpdateMetaTV :exec
UPDATE
    user_contact_methods
SET
    metadata = jsonb_set(jsonb_set(metadata, '{CarrierV1}', $3::jsonb), '{CarrierV1,UpdatedAt}',('"' || NOW()::timestamptz AT TIME ZONE 'UTC' || '"')::jsonb) 
WHERE
    type = $1
    AND value = $2
`

type ContactMethodUpdateMetaTVParams struct {
	Type      EnumUserContactMethodType
	Value     string
	CarrierV1 json.RawMessage
}

func (q *Queries) ContactMethodUpdateMetaTV(ctx context.Context, arg ContactMethodUpdateMetaTVParams) error {
	_, err := q.db.ExecContext(ctx, contactMethodUpdateMetaTV, arg.Type, arg.Value, arg.CarrierV1)
	return err
}

const createCalSub = `-- name: CreateCalSub :one
INSERT INTO user_calendar_subscriptions(id, NAME, user_id, disabled, schedule_id, config)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    created_at
`

type CreateCalSubParams struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
}

func (q *Queries) CreateCalSub(ctx context.Context, arg CreateCalSubParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createCalSub,
		arg.ID,
		arg.Name,
		arg.UserID,
		arg.Disabled,
		arg.ScheduleID,
		arg.Config,
	)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const deleteContactMethod = `-- name: DeleteContactMethod :exec
DELETE FROM user_contact_methods
WHERE id = ANY ($1::uuid[])
`

func (q *Queries) DeleteContactMethod(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteContactMethod, pq.Array(dollar_1))
	return err
}

const deleteManyCalSub = `-- name: DeleteManyCalSub :exec
DELETE FROM user_calendar_subscriptions
WHERE id = ANY ($1::uuid[])
    AND user_id = $2
`

type DeleteManyCalSubParams struct {
	Column1 []uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) DeleteManyCalSub(ctx context.Context, arg DeleteManyCalSubParams) error {
	_, err := q.db.ExecContext(ctx, deleteManyCalSub, pq.Array(arg.Column1), arg.UserID)
	return err
}

const findManyCalSubByUser = `-- name: FindManyCalSubByUser :many
SELECT
    id,
    NAME,
    user_id,
    disabled,
    schedule_id,
    config,
    last_access
FROM
    user_calendar_subscriptions
WHERE
    user_id = $1
`

type FindManyCalSubByUserRow struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
	LastAccess sql.NullTime
}

func (q *Queries) FindManyCalSubByUser(ctx context.Context, userID uuid.UUID) ([]FindManyCalSubByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, findManyCalSubByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindManyCalSubByUserRow
	for rows.Next() {
		var i FindManyCalSubByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Disabled,
			&i.ScheduleID,
			&i.Config,
			&i.LastAccess,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOneCalSub = `-- name: FindOneCalSub :one
SELECT
    id,
    NAME,
    user_id,
    disabled,
    schedule_id,
    config,
    last_access
FROM
    user_calendar_subscriptions
WHERE
    id = $1
`

type FindOneCalSubRow struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
	LastAccess sql.NullTime
}

func (q *Queries) FindOneCalSub(ctx context.Context, id uuid.UUID) (FindOneCalSubRow, error) {
	row := q.db.QueryRowContext(ctx, findOneCalSub, id)
	var i FindOneCalSubRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Disabled,
		&i.ScheduleID,
		&i.Config,
		&i.LastAccess,
	)
	return i, err
}

const findOneCalSubForUpdate = `-- name: FindOneCalSubForUpdate :one
SELECT
    id,
    NAME,
    user_id,
    disabled,
    schedule_id,
    config,
    last_access
FROM
    user_calendar_subscriptions
WHERE
    id = $1
FOR UPDATE
`

type FindOneCalSubForUpdateRow struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
	LastAccess sql.NullTime
}

func (q *Queries) FindOneCalSubForUpdate(ctx context.Context, id uuid.UUID) (FindOneCalSubForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, findOneCalSubForUpdate, id)
	var i FindOneCalSubForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Disabled,
		&i.ScheduleID,
		&i.Config,
		&i.LastAccess,
	)
	return i, err
}

const intKeyCreate = `-- name: IntKeyCreate :exec
INSERT INTO integration_keys(id, name, type, service_id)
    VALUES ($1, $2, $3, $4)
`

type IntKeyCreateParams struct {
	ID        uuid.UUID
	Name      string
	Type      EnumIntegrationKeysType
	ServiceID uuid.UUID
}

func (q *Queries) IntKeyCreate(ctx context.Context, arg IntKeyCreateParams) error {
	_, err := q.db.ExecContext(ctx, intKeyCreate,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.ServiceID,
	)
	return err
}

const intKeyDelete = `-- name: IntKeyDelete :exec
DELETE FROM integration_keys
WHERE id = ANY ($1::uuid[])
`

func (q *Queries) IntKeyDelete(ctx context.Context, ids []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, intKeyDelete, pq.Array(ids))
	return err
}

const intKeyFindByService = `-- name: IntKeyFindByService :many
SELECT
    id,
    name,
    type,
    service_id
FROM
    integration_keys
WHERE
    service_id = $1
`

type IntKeyFindByServiceRow struct {
	ID        uuid.UUID
	Name      string
	Type      EnumIntegrationKeysType
	ServiceID uuid.UUID
}

func (q *Queries) IntKeyFindByService(ctx context.Context, serviceID uuid.UUID) ([]IntKeyFindByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, intKeyFindByService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IntKeyFindByServiceRow
	for rows.Next() {
		var i IntKeyFindByServiceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ServiceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const intKeyFindOne = `-- name: IntKeyFindOne :one
SELECT
    id,
    name,
    type,
    service_id
FROM
    integration_keys
WHERE
    id = $1
`

type IntKeyFindOneRow struct {
	ID        uuid.UUID
	Name      string
	Type      EnumIntegrationKeysType
	ServiceID uuid.UUID
}

func (q *Queries) IntKeyFindOne(ctx context.Context, id uuid.UUID) (IntKeyFindOneRow, error) {
	row := q.db.QueryRowContext(ctx, intKeyFindOne, id)
	var i IntKeyFindOneRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ServiceID,
	)
	return i, err
}

const intKeyGetServiceID = `-- name: IntKeyGetServiceID :one
SELECT
    service_id
FROM
    integration_keys
WHERE
    id = $1
    AND type = $2
`

type IntKeyGetServiceIDParams struct {
	ID   uuid.UUID
	Type EnumIntegrationKeysType
}

func (q *Queries) IntKeyGetServiceID(ctx context.Context, arg IntKeyGetServiceIDParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, intKeyGetServiceID, arg.ID, arg.Type)
	var service_id uuid.UUID
	err := row.Scan(&service_id)
	return service_id, err
}

const labelDeleteKeyByTarget = `-- name: LabelDeleteKeyByTarget :exec
DELETE FROM labels
WHERE key = $1
    AND tgt_service_id = $2
`

type LabelDeleteKeyByTargetParams struct {
	Key          string
	TgtServiceID uuid.UUID
}

func (q *Queries) LabelDeleteKeyByTarget(ctx context.Context, arg LabelDeleteKeyByTargetParams) error {
	_, err := q.db.ExecContext(ctx, labelDeleteKeyByTarget, arg.Key, arg.TgtServiceID)
	return err
}

const labelFindAllByTarget = `-- name: LabelFindAllByTarget :many
SELECT
    key,
    value
FROM
    labels
WHERE
    tgt_service_id = $1
`

type LabelFindAllByTargetRow struct {
	Key   string
	Value string
}

func (q *Queries) LabelFindAllByTarget(ctx context.Context, tgtServiceID uuid.UUID) ([]LabelFindAllByTargetRow, error) {
	rows, err := q.db.QueryContext(ctx, labelFindAllByTarget, tgtServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LabelFindAllByTargetRow
	for rows.Next() {
		var i LabelFindAllByTargetRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const labelSetByTarget = `-- name: LabelSetByTarget :exec
INSERT INTO labels(key, value, tgt_service_id)
    VALUES ($1, $2, $3)
ON CONFLICT (key, tgt_service_id)
    DO UPDATE SET
        value = $2
`

type LabelSetByTargetParams struct {
	Key          string
	Value        string
	TgtServiceID uuid.UUID
}

func (q *Queries) LabelSetByTarget(ctx context.Context, arg LabelSetByTargetParams) error {
	_, err := q.db.ExecContext(ctx, labelSetByTarget, arg.Key, arg.Value, arg.TgtServiceID)
	return err
}

const labelUniqueKeys = `-- name: LabelUniqueKeys :many
SELECT DISTINCT
    key
FROM
    labels
`

func (q *Queries) LabelUniqueKeys(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, labelUniqueKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockOneAlertService = `-- name: LockOneAlertService :one
SELECT
    maintenance_expires_at NOTNULL::bool AS is_maint_mode,
    alerts.status
FROM
    services svc
    JOIN alerts ON alerts.service_id = svc.id
WHERE
    alerts.id = $1
FOR UPDATE
`

type LockOneAlertServiceRow struct {
	IsMaintMode bool
	Status      EnumAlertStatus
}

func (q *Queries) LockOneAlertService(ctx context.Context, id int64) (LockOneAlertServiceRow, error) {
	row := q.db.QueryRowContext(ctx, lockOneAlertService, id)
	var i LockOneAlertServiceRow
	err := row.Scan(&i.IsMaintMode, &i.Status)
	return i, err
}

const noticeUnackedAlertsByService = `-- name: NoticeUnackedAlertsByService :one
SELECT
    count(*),
    (
        SELECT
            max
        FROM
            config_limits
        WHERE
            id = 'unacked_alerts_per_service'
    )
FROM
    alerts
WHERE
    service_id = $1::uuid
    AND status = 'triggered'
`

type NoticeUnackedAlertsByServiceRow struct {
	Count int64
	Max   int32
}

func (q *Queries) NoticeUnackedAlertsByService(ctx context.Context, dollar_1 uuid.UUID) (NoticeUnackedAlertsByServiceRow, error) {
	row := q.db.QueryRowContext(ctx, noticeUnackedAlertsByService, dollar_1)
	var i NoticeUnackedAlertsByServiceRow
	err := row.Scan(&i.Count, &i.Max)
	return i, err
}

const now = `-- name: Now :one
SELECT
    now()::timestamptz
`

func (q *Queries) Now(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, now)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const overrideSearch = `-- name: OverrideSearch :many
WITH AFTER AS (
    SELECT
        id,
        start_time,
        end_time
    FROM
        user_overrides
    WHERE
        id = $8::uuid
)
SELECT
    o.id,
    o.start_time,
    o.end_time,
    add_user_id,
    remove_user_id,
    tgt_schedule_id
FROM
    user_overrides o
    LEFT JOIN AFTER ON TRUE
WHERE ($1::uuid[] ISNULL
    OR o.id <> ALL ($1))
AND ($2::uuid ISNULL
    OR o.tgt_schedule_id = $2)
AND ($3::uuid[] ISNULL
    OR add_user_id = ANY ($3::uuid[])
    OR remove_user_id = ANY ($3::uuid[]))
AND ($4::uuid[] ISNULL
    OR add_user_id = ANY ($4::uuid[]))
AND ($5::uuid[] ISNULL
    OR remove_user_id = ANY ($5::uuid[]))
AND (
    /* only include overrides that end after the search start */
    $6::timestamptz ISNULL
    OR o.end_time > $6)
AND (
    /* only include overrides that start before/within the search end */
    $7::timestamptz ISNULL
    OR o.start_time <= $7)
AND (
    /* resume search after specified "cursor" override */
    $8::uuid ISNULL
    OR (o.start_time > after.start_time
        OR (o.start_time = after.start_time
            AND o.end_time > after.end_time)
        OR (o.start_time = after.start_time
            AND o.end_time = after.end_time
            AND o.id > after.id)))
ORDER BY
    o.start_time,
    o.end_time,
    o.id
LIMIT 150
`

type OverrideSearchParams struct {
	Omit         []uuid.UUID
	ScheduleID   uuid.NullUUID
	AnyUserID    []uuid.UUID
	AddUserID    []uuid.UUID
	RemoveUserID []uuid.UUID
	SearchStart  sql.NullTime
	SearchEnd    sql.NullTime
	AfterID      uuid.NullUUID
}

type OverrideSearchRow struct {
	ID            uuid.UUID
	StartTime     time.Time
	EndTime       time.Time
	AddUserID     uuid.NullUUID
	RemoveUserID  uuid.NullUUID
	TgtScheduleID uuid.UUID
}

func (q *Queries) OverrideSearch(ctx context.Context, arg OverrideSearchParams) ([]OverrideSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, overrideSearch,
		pq.Array(arg.Omit),
		arg.ScheduleID,
		pq.Array(arg.AnyUserID),
		pq.Array(arg.AddUserID),
		pq.Array(arg.RemoveUserID),
		arg.SearchStart,
		arg.SearchEnd,
		arg.AfterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverrideSearchRow
	for rows.Next() {
		var i OverrideSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.StartTime,
			&i.EndTime,
			&i.AddUserID,
			&i.RemoveUserID,
			&i.TgtScheduleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const requestAlertEscalationByTime = `-- name: RequestAlertEscalationByTime :one
UPDATE
    escalation_policy_state
SET
    force_escalation = TRUE
WHERE
    alert_id = $1
    AND (last_escalation <= $2::timestamptz
        OR last_escalation IS NULL)
RETURNING
    TRUE
`

type RequestAlertEscalationByTimeParams struct {
	AlertID int64
	Column2 time.Time
}

func (q *Queries) RequestAlertEscalationByTime(ctx context.Context, arg RequestAlertEscalationByTimeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, requestAlertEscalationByTime, arg.AlertID, arg.Column2)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const scheduleFindManyByUser = `-- name: ScheduleFindManyByUser :many
SELECT
    description, id, last_processed, name, time_zone
FROM
    schedules
WHERE
    id = ANY (
        SELECT
            schedule_id
        FROM
            schedule_rules
        WHERE
            tgt_user_id = $1
            OR tgt_rotation_id = ANY (
                SELECT
                    rotation_id
                FROM
                    rotation_participants
                WHERE
                    user_id = $1))
`

func (q *Queries) ScheduleFindManyByUser(ctx context.Context, tgtUserID uuid.NullUUID) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, scheduleFindManyByUser, tgtUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.Description,
			&i.ID,
			&i.LastProcessed,
			&i.Name,
			&i.TimeZone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAlertFeedback = `-- name: SetAlertFeedback :exec
INSERT INTO alert_feedback(alert_id, noise_reason)
    VALUES ($1, $2)
ON CONFLICT (alert_id)
    DO UPDATE SET
        noise_reason = $2
    WHERE
        alert_feedback.alert_id = $1
`

type SetAlertFeedbackParams struct {
	AlertID     int64
	NoiseReason string
}

func (q *Queries) SetAlertFeedback(ctx context.Context, arg SetAlertFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, setAlertFeedback, arg.AlertID, arg.NoiseReason)
	return err
}

const setManyAlertFeedback = `-- name: SetManyAlertFeedback :many
INSERT INTO alert_feedback(alert_id, noise_reason)
    VALUES (unnest($1::bigint[]), $2)
ON CONFLICT (alert_id)
    DO UPDATE SET
        noise_reason = excluded.noise_reason
    WHERE
        alert_feedback.alert_id = excluded.alert_id
    RETURNING
        alert_id
`

type SetManyAlertFeedbackParams struct {
	AlertIds    []int64
	NoiseReason string
}

func (q *Queries) SetManyAlertFeedback(ctx context.Context, arg SetManyAlertFeedbackParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, setManyAlertFeedback, pq.Array(arg.AlertIds), arg.NoiseReason)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var alert_id int64
		if err := rows.Scan(&alert_id); err != nil {
			return nil, err
		}
		items = append(items, alert_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statusMgrCMInfo = `-- name: StatusMgrCMInfo :one
SELECT
    user_id,
    type
FROM
    user_contact_methods
WHERE
    id = $1
    AND NOT disabled
    AND enable_status_updates
`

type StatusMgrCMInfoRow struct {
	UserID uuid.UUID
	Type   EnumUserContactMethodType
}

func (q *Queries) StatusMgrCMInfo(ctx context.Context, id uuid.UUID) (StatusMgrCMInfoRow, error) {
	row := q.db.QueryRowContext(ctx, statusMgrCMInfo, id)
	var i StatusMgrCMInfoRow
	err := row.Scan(&i.UserID, &i.Type)
	return i, err
}

const statusMgrCleanupDisabledSubs = `-- name: StatusMgrCleanupDisabledSubs :exec
DELETE FROM alert_status_subscriptions sub USING user_contact_methods cm
WHERE sub.contact_method_id = cm.id
    AND (cm.disabled
        OR NOT cm.enable_status_updates)
`

func (q *Queries) StatusMgrCleanupDisabledSubs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, statusMgrCleanupDisabledSubs)
	return err
}

const statusMgrCleanupStaleSubs = `-- name: StatusMgrCleanupStaleSubs :exec
DELETE FROM alert_status_subscriptions sub
WHERE sub.updated_at < now() - '7 days'::interval
`

func (q *Queries) StatusMgrCleanupStaleSubs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, statusMgrCleanupStaleSubs)
	return err
}

const statusMgrDeleteSub = `-- name: StatusMgrDeleteSub :exec
DELETE FROM alert_status_subscriptions
WHERE id = $1
`

func (q *Queries) StatusMgrDeleteSub(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, statusMgrDeleteSub, id)
	return err
}

const statusMgrLogEntry = `-- name: StatusMgrLogEntry :one
SELECT
    id,
    sub_user_id AS user_id
FROM
    alert_logs
WHERE
    alert_id = $1::bigint
    AND event = $2::enum_alert_log_event
    AND timestamp > now() - '1 hour'::interval
ORDER BY
    id DESC
LIMIT 1
`

type StatusMgrLogEntryParams struct {
	AlertID   int64
	EventType EnumAlertLogEvent
}

type StatusMgrLogEntryRow struct {
	ID     int64
	UserID uuid.NullUUID
}

func (q *Queries) StatusMgrLogEntry(ctx context.Context, arg StatusMgrLogEntryParams) (StatusMgrLogEntryRow, error) {
	row := q.db.QueryRowContext(ctx, statusMgrLogEntry, arg.AlertID, arg.EventType)
	var i StatusMgrLogEntryRow
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const statusMgrNextUpdate = `-- name: StatusMgrNextUpdate :one
SELECT
    sub.id,
    channel_id,
    contact_method_id,
    alert_id,
(
        SELECT
            status
        FROM
            alerts a
        WHERE
            a.id = sub.alert_id)
FROM
    alert_status_subscriptions sub
WHERE
    sub.last_alert_status !=(
        SELECT
            status
        FROM
            alerts a
        WHERE
            a.id = sub.alert_id)
LIMIT 1
FOR UPDATE
    SKIP LOCKED
`

type StatusMgrNextUpdateRow struct {
	ID              int64
	ChannelID       uuid.NullUUID
	ContactMethodID uuid.NullUUID
	AlertID         int64
	Status          EnumAlertStatus
}

func (q *Queries) StatusMgrNextUpdate(ctx context.Context) (StatusMgrNextUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, statusMgrNextUpdate)
	var i StatusMgrNextUpdateRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ContactMethodID,
		&i.AlertID,
		&i.Status,
	)
	return i, err
}

const statusMgrSendChannelMsg = `-- name: StatusMgrSendChannelMsg :exec
INSERT INTO outgoing_messages(id, message_type, channel_id, alert_id, alert_log_id)
    VALUES ($1::uuid, 'alert_status_update', $2::uuid, $3::bigint, $4)
`

type StatusMgrSendChannelMsgParams struct {
	ID        uuid.UUID
	ChannelID uuid.UUID
	AlertID   int64
	LogID     sql.NullInt64
}

func (q *Queries) StatusMgrSendChannelMsg(ctx context.Context, arg StatusMgrSendChannelMsgParams) error {
	_, err := q.db.ExecContext(ctx, statusMgrSendChannelMsg,
		arg.ID,
		arg.ChannelID,
		arg.AlertID,
		arg.LogID,
	)
	return err
}

const statusMgrSendUserMsg = `-- name: StatusMgrSendUserMsg :exec
INSERT INTO outgoing_messages(id, message_type, contact_method_id, user_id, alert_id, alert_log_id)
    VALUES ($1::uuid, 'alert_status_update', $2::uuid, $3::uuid, $4::bigint, $5)
`

type StatusMgrSendUserMsgParams struct {
	ID      uuid.UUID
	CmID    uuid.UUID
	UserID  uuid.UUID
	AlertID int64
	LogID   sql.NullInt64
}

func (q *Queries) StatusMgrSendUserMsg(ctx context.Context, arg StatusMgrSendUserMsgParams) error {
	_, err := q.db.ExecContext(ctx, statusMgrSendUserMsg,
		arg.ID,
		arg.CmID,
		arg.UserID,
		arg.AlertID,
		arg.LogID,
	)
	return err
}

const statusMgrUpdateCMForced = `-- name: StatusMgrUpdateCMForced :exec
UPDATE
    user_contact_methods
SET
    enable_status_updates = TRUE
WHERE
    TYPE = 'SLACK_DM'
    AND NOT enable_status_updates
`

func (q *Queries) StatusMgrUpdateCMForced(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, statusMgrUpdateCMForced)
	return err
}

const statusMgrUpdateSub = `-- name: StatusMgrUpdateSub :exec
UPDATE
    alert_status_subscriptions
SET
    last_alert_status = $2,
    updated_at = now()
WHERE
    id = $1
`

type StatusMgrUpdateSubParams struct {
	ID              int64
	LastAlertStatus EnumAlertStatus
}

func (q *Queries) StatusMgrUpdateSub(ctx context.Context, arg StatusMgrUpdateSubParams) error {
	_, err := q.db.ExecContext(ctx, statusMgrUpdateSub, arg.ID, arg.LastAlertStatus)
	return err
}

const updateCalSub = `-- name: UpdateCalSub :exec
UPDATE
    user_calendar_subscriptions
SET
    NAME = $1,
    disabled = $2,
    config = $3,
    last_update = now()
WHERE
    id = $4
    AND user_id = $5
`

type UpdateCalSubParams struct {
	Name     string
	Disabled bool
	Config   json.RawMessage
	ID       uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) UpdateCalSub(ctx context.Context, arg UpdateCalSubParams) error {
	_, err := q.db.ExecContext(ctx, updateCalSub,
		arg.Name,
		arg.Disabled,
		arg.Config,
		arg.ID,
		arg.UserID,
	)
	return err
}

const userFavFindAll = `-- name: UserFavFindAll :many
SELECT
    tgt_service_id,
    tgt_schedule_id,
    tgt_rotation_id,
    tgt_escalation_policy_id,
    tgt_user_id
FROM
    user_favorites
WHERE
    user_id = $1
    AND ((tgt_service_id NOTNULL
            AND $2::bool)
        OR (tgt_schedule_id NOTNULL
            AND $3::bool)
        OR (tgt_rotation_id NOTNULL
            AND $4::bool)
        OR (tgt_escalation_policy_id NOTNULL
            AND $5::bool)
        OR (tgt_user_id NOTNULL
            AND $6::bool))
`

type UserFavFindAllParams struct {
	UserID                  uuid.UUID
	AllowServices           bool
	AllowSchedules          bool
	AllowRotations          bool
	AllowEscalationPolicies bool
	AllowUsers              bool
}

type UserFavFindAllRow struct {
	TgtServiceID          uuid.NullUUID
	TgtScheduleID         uuid.NullUUID
	TgtRotationID         uuid.NullUUID
	TgtEscalationPolicyID uuid.NullUUID
	TgtUserID             uuid.NullUUID
}

func (q *Queries) UserFavFindAll(ctx context.Context, arg UserFavFindAllParams) ([]UserFavFindAllRow, error) {
	rows, err := q.db.QueryContext(ctx, userFavFindAll,
		arg.UserID,
		arg.AllowServices,
		arg.AllowSchedules,
		arg.AllowRotations,
		arg.AllowEscalationPolicies,
		arg.AllowUsers,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFavFindAllRow
	for rows.Next() {
		var i UserFavFindAllRow
		if err := rows.Scan(
			&i.TgtServiceID,
			&i.TgtScheduleID,
			&i.TgtRotationID,
			&i.TgtEscalationPolicyID,
			&i.TgtUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFavSet = `-- name: UserFavSet :exec
INSERT INTO user_favorites(user_id, tgt_service_id, tgt_schedule_id, tgt_rotation_id, tgt_escalation_policy_id, tgt_user_id)
    VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT
    DO NOTHING
`

type UserFavSetParams struct {
	UserID                uuid.UUID
	TgtServiceID          uuid.NullUUID
	TgtScheduleID         uuid.NullUUID
	TgtRotationID         uuid.NullUUID
	TgtEscalationPolicyID uuid.NullUUID
	TgtUserID             uuid.NullUUID
}

func (q *Queries) UserFavSet(ctx context.Context, arg UserFavSetParams) error {
	_, err := q.db.ExecContext(ctx, userFavSet,
		arg.UserID,
		arg.TgtServiceID,
		arg.TgtScheduleID,
		arg.TgtRotationID,
		arg.TgtEscalationPolicyID,
		arg.TgtUserID,
	)
	return err
}

const userFavUnset = `-- name: UserFavUnset :exec
DELETE FROM user_favorites
WHERE user_id = $1
    AND tgt_service_id = $2
    OR tgt_schedule_id = $3
    OR tgt_rotation_id = $4
    OR tgt_escalation_policy_id = $5
    OR tgt_user_id = $6
`

type UserFavUnsetParams struct {
	UserID                uuid.UUID
	TgtServiceID          uuid.NullUUID
	TgtScheduleID         uuid.NullUUID
	TgtRotationID         uuid.NullUUID
	TgtEscalationPolicyID uuid.NullUUID
	TgtUserID             uuid.NullUUID
}

func (q *Queries) UserFavUnset(ctx context.Context, arg UserFavUnsetParams) error {
	_, err := q.db.ExecContext(ctx, userFavUnset,
		arg.UserID,
		arg.TgtServiceID,
		arg.TgtScheduleID,
		arg.TgtRotationID,
		arg.TgtEscalationPolicyID,
		arg.TgtUserID,
	)
	return err
}
