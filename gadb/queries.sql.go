// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package gadb

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
	"github.com/target/goalert/util/timeutil"
)

const aPIKeyAuthCheck = `-- name: APIKeyAuthCheck :one
SELECT
    TRUE
FROM
    gql_api_keys
WHERE
    gql_api_keys.id = $1
    AND gql_api_keys.deleted_at IS NULL
    AND gql_api_keys.expires_at > now()
`

func (q *Queries) APIKeyAuthCheck(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, aPIKeyAuthCheck, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const aPIKeyAuthPolicy = `-- name: APIKeyAuthPolicy :one
SELECT
    gql_api_keys.policy
FROM
    gql_api_keys
WHERE
    gql_api_keys.id = $1
    AND gql_api_keys.deleted_at IS NULL
    AND gql_api_keys.expires_at > now()
`

// APIKeyAuth returns the API key policy with the given id, if it exists and is not expired.
func (q *Queries) APIKeyAuthPolicy(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, aPIKeyAuthPolicy, id)
	var policy json.RawMessage
	err := row.Scan(&policy)
	return policy, err
}

const aPIKeyDelete = `-- name: APIKeyDelete :exec
UPDATE
    gql_api_keys
SET
    deleted_at = now(),
    deleted_by = $2
WHERE
    id = $1
`

type APIKeyDeleteParams struct {
	ID        uuid.UUID
	DeletedBy uuid.NullUUID
}

func (q *Queries) APIKeyDelete(ctx context.Context, arg APIKeyDeleteParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyDelete, arg.ID, arg.DeletedBy)
	return err
}

const aPIKeyForUpdate = `-- name: APIKeyForUpdate :one
SELECT
    name,
    description
FROM
    gql_api_keys
WHERE
    id = $1
    AND deleted_at IS NULL
FOR UPDATE
`

type APIKeyForUpdateRow struct {
	Name        string
	Description string
}

func (q *Queries) APIKeyForUpdate(ctx context.Context, id uuid.UUID) (APIKeyForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, aPIKeyForUpdate, id)
	var i APIKeyForUpdateRow
	err := row.Scan(&i.Name, &i.Description)
	return i, err
}

const aPIKeyInsert = `-- name: APIKeyInsert :exec
INSERT INTO gql_api_keys(id, name, description, POLICY, created_by, updated_by, expires_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type APIKeyInsertParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	Policy      json.RawMessage
	CreatedBy   uuid.NullUUID
	UpdatedBy   uuid.NullUUID
	ExpiresAt   time.Time
}

func (q *Queries) APIKeyInsert(ctx context.Context, arg APIKeyInsertParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyInsert,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Policy,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.ExpiresAt,
	)
	return err
}

const aPIKeyList = `-- name: APIKeyList :many
SELECT
    gql_api_keys.created_at, gql_api_keys.created_by, gql_api_keys.deleted_at, gql_api_keys.deleted_by, gql_api_keys.description, gql_api_keys.expires_at, gql_api_keys.id, gql_api_keys.name, gql_api_keys.policy, gql_api_keys.updated_at, gql_api_keys.updated_by,
    gql_api_key_usage.used_at AS last_used_at,
    gql_api_key_usage.user_agent AS last_user_agent,
    gql_api_key_usage.ip_address AS last_ip_address
FROM
    gql_api_keys
    LEFT JOIN gql_api_key_usage ON gql_api_keys.id = gql_api_key_usage.api_key_id
WHERE
    gql_api_keys.deleted_at IS NULL
`

type APIKeyListRow struct {
	CreatedAt     time.Time
	CreatedBy     uuid.NullUUID
	DeletedAt     sql.NullTime
	DeletedBy     uuid.NullUUID
	Description   string
	ExpiresAt     time.Time
	ID            uuid.UUID
	Name          string
	Policy        json.RawMessage
	UpdatedAt     time.Time
	UpdatedBy     uuid.NullUUID
	LastUsedAt    sql.NullTime
	LastUserAgent sql.NullString
	LastIpAddress pqtype.Inet
}

// APIKeyList returns all API keys, along with the last time they were used.
func (q *Queries) APIKeyList(ctx context.Context) ([]APIKeyListRow, error) {
	rows, err := q.db.QueryContext(ctx, aPIKeyList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []APIKeyListRow
	for rows.Next() {
		var i APIKeyListRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.CreatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.Description,
			&i.ExpiresAt,
			&i.ID,
			&i.Name,
			&i.Policy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.LastUsedAt,
			&i.LastUserAgent,
			&i.LastIpAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aPIKeyRecordUsage = `-- name: APIKeyRecordUsage :exec
INSERT INTO gql_api_key_usage(api_key_id, user_agent, ip_address)
    VALUES ($1::uuid, $2::text, $3::inet)
ON CONFLICT (api_key_id)
    DO UPDATE SET
        used_at = now(), user_agent = $2::text, ip_address = $3::inet
`

type APIKeyRecordUsageParams struct {
	KeyID     uuid.UUID
	UserAgent string
	IpAddress pqtype.Inet
}

// APIKeyRecordUsage records the usage of an API key.
func (q *Queries) APIKeyRecordUsage(ctx context.Context, arg APIKeyRecordUsageParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyRecordUsage, arg.KeyID, arg.UserAgent, arg.IpAddress)
	return err
}

const aPIKeyUpdate = `-- name: APIKeyUpdate :exec
UPDATE
    gql_api_keys
SET
    name = $2,
    description = $3,
    updated_at = now(),
    updated_by = $4
WHERE
    id = $1
`

type APIKeyUpdateParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	UpdatedBy   uuid.NullUUID
}

func (q *Queries) APIKeyUpdate(ctx context.Context, arg APIKeyUpdateParams) error {
	_, err := q.db.ExecContext(ctx, aPIKeyUpdate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedBy,
	)
	return err
}

const activeTxCount = `-- name: ActiveTxCount :one
SELECT COUNT(*)
FROM pg_stat_activity
WHERE "state" <> 'idle'
    AND "xact_start" <= $1
`

func (q *Queries) ActiveTxCount(ctx context.Context, xactStart time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, activeTxCount, xactStart)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const alertFeedback = `-- name: AlertFeedback :many
SELECT
    alert_id,
    noise_reason
FROM
    alert_feedback
WHERE
    alert_id = ANY ($1::int[])
`

type AlertFeedbackRow struct {
	AlertID     int64
	NoiseReason string
}

func (q *Queries) AlertFeedback(ctx context.Context, dollar_1 []int32) ([]AlertFeedbackRow, error) {
	rows, err := q.db.QueryContext(ctx, alertFeedback, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertFeedbackRow
	for rows.Next() {
		var i AlertFeedbackRow
		if err := rows.Scan(&i.AlertID, &i.NoiseReason); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const alertHasEPState = `-- name: AlertHasEPState :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            escalation_policy_state
        WHERE
            alert_id = $1) AS has_ep_state
`

func (q *Queries) AlertHasEPState(ctx context.Context, alertID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, alertHasEPState, alertID)
	var has_ep_state bool
	err := row.Scan(&has_ep_state)
	return has_ep_state, err
}

const alertLogHBIntervalMinutes = `-- name: AlertLogHBIntervalMinutes :one
SELECT
    (EXTRACT(EPOCH FROM heartbeat_interval) / 60)::int
FROM
    heartbeat_monitors
WHERE
    id = $1
`

func (q *Queries) AlertLogHBIntervalMinutes(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, alertLogHBIntervalMinutes, id)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const alertLogInsertEP = `-- name: AlertLogInsertEP :exec
INSERT INTO alert_logs(alert_id, event, sub_type, sub_user_id, sub_integration_key_id, sub_hb_monitor_id, sub_channel_id, sub_classifier, meta, message)
SELECT
    a.id,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
FROM
    alerts a
    JOIN services svc ON svc.id = a.service_id
        AND svc.escalation_policy_id = $1
WHERE
    a.status != 'closed'
`

type AlertLogInsertEPParams struct {
	EscalationPolicyID  uuid.UUID
	Event               EnumAlertLogEvent
	SubType             NullEnumAlertLogSubjectType
	SubUserID           uuid.NullUUID
	SubIntegrationKeyID uuid.NullUUID
	SubHbMonitorID      uuid.NullUUID
	SubChannelID        uuid.NullUUID
	SubClassifier       string
	Meta                pqtype.NullRawMessage
	Message             string
}

func (q *Queries) AlertLogInsertEP(ctx context.Context, arg AlertLogInsertEPParams) error {
	_, err := q.db.ExecContext(ctx, alertLogInsertEP,
		arg.EscalationPolicyID,
		arg.Event,
		arg.SubType,
		arg.SubUserID,
		arg.SubIntegrationKeyID,
		arg.SubHbMonitorID,
		arg.SubChannelID,
		arg.SubClassifier,
		arg.Meta,
		arg.Message,
	)
	return err
}

const alertLogInsertMany = `-- name: AlertLogInsertMany :exec
INSERT INTO alert_logs(alert_id, event, sub_type, sub_user_id, sub_integration_key_id, sub_hb_monitor_id, sub_channel_id, sub_classifier, meta, message)
SELECT
    unnest,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
FROM
    unnest($1::bigint[])
`

type AlertLogInsertManyParams struct {
	Column1             []int64
	Event               EnumAlertLogEvent
	SubType             NullEnumAlertLogSubjectType
	SubUserID           uuid.NullUUID
	SubIntegrationKeyID uuid.NullUUID
	SubHbMonitorID      uuid.NullUUID
	SubChannelID        uuid.NullUUID
	SubClassifier       string
	Meta                pqtype.NullRawMessage
	Message             string
}

func (q *Queries) AlertLogInsertMany(ctx context.Context, arg AlertLogInsertManyParams) error {
	_, err := q.db.ExecContext(ctx, alertLogInsertMany,
		pq.Array(arg.Column1),
		arg.Event,
		arg.SubType,
		arg.SubUserID,
		arg.SubIntegrationKeyID,
		arg.SubHbMonitorID,
		arg.SubChannelID,
		arg.SubClassifier,
		arg.Meta,
		arg.Message,
	)
	return err
}

const alertLogInsertSvc = `-- name: AlertLogInsertSvc :exec
INSERT INTO alert_logs(alert_id, event, sub_type, sub_user_id, sub_integration_key_id, sub_hb_monitor_id, sub_channel_id, sub_classifier, meta, message)
SELECT
    a.id,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
FROM
    alerts a
WHERE
    a.service_id = $1
    AND (($2 = 'closed'::enum_alert_log_event
            AND a.status != 'closed')
        OR ($2::enum_alert_log_event IN ('acknowledged', 'notification_sent')
            AND a.status = 'triggered'))
`

type AlertLogInsertSvcParams struct {
	ServiceID           uuid.NullUUID
	Event               EnumAlertLogEvent
	SubType             NullEnumAlertLogSubjectType
	SubUserID           uuid.NullUUID
	SubIntegrationKeyID uuid.NullUUID
	SubHbMonitorID      uuid.NullUUID
	SubChannelID        uuid.NullUUID
	SubClassifier       string
	Meta                pqtype.NullRawMessage
	Message             string
}

func (q *Queries) AlertLogInsertSvc(ctx context.Context, arg AlertLogInsertSvcParams) error {
	_, err := q.db.ExecContext(ctx, alertLogInsertSvc,
		arg.ServiceID,
		arg.Event,
		arg.SubType,
		arg.SubUserID,
		arg.SubIntegrationKeyID,
		arg.SubHbMonitorID,
		arg.SubChannelID,
		arg.SubClassifier,
		arg.Meta,
		arg.Message,
	)
	return err
}

const alertLogLookupCMDest = `-- name: AlertLogLookupCMDest :one
SELECT
    dest
FROM
    user_contact_methods
WHERE
    id = $1
`

func (q *Queries) AlertLogLookupCMDest(ctx context.Context, id uuid.UUID) (NullDestV1, error) {
	row := q.db.QueryRowContext(ctx, alertLogLookupCMDest, id)
	var dest NullDestV1
	err := row.Scan(&dest)
	return dest, err
}

const alertLogLookupCallbackDest = `-- name: AlertLogLookupCallbackDest :one
SELECT
    coalesce(cm.dest, ch.dest) AS dest
FROM
    outgoing_messages log
    LEFT JOIN user_contact_methods cm ON cm.id = log.contact_method_id
    LEFT JOIN notification_channels ch ON ch.id = log.channel_id
WHERE
    log.id = $1
`

func (q *Queries) AlertLogLookupCallbackDest(ctx context.Context, id uuid.UUID) (NullDestV1, error) {
	row := q.db.QueryRowContext(ctx, alertLogLookupCallbackDest, id)
	var dest NullDestV1
	err := row.Scan(&dest)
	return dest, err
}

const alertLogLookupNCDest = `-- name: AlertLogLookupNCDest :one
SELECT
    dest
FROM
    notification_channels
WHERE
    id = $1
`

func (q *Queries) AlertLogLookupNCDest(ctx context.Context, id uuid.UUID) (NullDestV1, error) {
	row := q.db.QueryRowContext(ctx, alertLogLookupNCDest, id)
	var dest NullDestV1
	err := row.Scan(&dest)
	return dest, err
}

const alertManyMetadata = `-- name: AlertManyMetadata :many
SELECT
    alert_id,
    metadata
FROM
    alert_data
WHERE
    alert_id = ANY ($1::bigint[])
`

type AlertManyMetadataRow struct {
	AlertID  int64
	Metadata pqtype.NullRawMessage
}

func (q *Queries) AlertManyMetadata(ctx context.Context, alertIds []int64) ([]AlertManyMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, alertManyMetadata, pq.Array(alertIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlertManyMetadataRow
	for rows.Next() {
		var i AlertManyMetadataRow
		if err := rows.Scan(&i.AlertID, &i.Metadata); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const alertMetadata = `-- name: AlertMetadata :one
SELECT
    metadata
FROM
    alert_data
WHERE
    alert_id = $1
`

func (q *Queries) AlertMetadata(ctx context.Context, alertID int64) (pqtype.NullRawMessage, error) {
	row := q.db.QueryRowContext(ctx, alertMetadata, alertID)
	var metadata pqtype.NullRawMessage
	err := row.Scan(&metadata)
	return metadata, err
}

const alertSetMetadata = `-- name: AlertSetMetadata :execrows
INSERT INTO alert_data(alert_id, metadata)
SELECT
    a.id,
    $2
FROM
    alerts a
WHERE
    a.id = $1
    AND a.status != 'closed'
    AND (a.service_id = $3
        OR $3 IS NULL) -- ensure the alert is associated with the service, if coming from an integration
ON CONFLICT (alert_id)
    DO UPDATE SET
        metadata = $2
    WHERE
        alert_data.alert_id = $1
`

type AlertSetMetadataParams struct {
	ID        int64
	Metadata  pqtype.NullRawMessage
	ServiceID uuid.NullUUID
}

func (q *Queries) AlertSetMetadata(ctx context.Context, arg AlertSetMetadataParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, alertSetMetadata, arg.ID, arg.Metadata, arg.ServiceID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const allPendingMsgDests = `-- name: AllPendingMsgDests :many
SELECT DISTINCT
    usr.name AS user_name,
    cm.dest AS cm_dest,
    nc.name AS nc_name,
    nc.dest AS nc_dest
FROM
    outgoing_messages om
    LEFT JOIN users usr ON usr.id = om.user_id
    LEFT JOIN notification_channels nc ON nc.id = om.channel_id
    LEFT JOIN user_contact_methods cm ON cm.id = om.contact_method_id
WHERE
    om.last_status = 'pending'
    AND (now() - om.created_at) > INTERVAL '15 seconds'
    AND (om.alert_id = $1::bigint
        OR (om.message_type = 'alert_notification_bundle'
            AND om.service_id = $2::uuid))
`

type AllPendingMsgDestsParams struct {
	AlertID   int64
	ServiceID uuid.UUID
}

type AllPendingMsgDestsRow struct {
	UserName sql.NullString
	CmDest   NullDestV1
	NcName   sql.NullString
	NcDest   NullDestV1
}

func (q *Queries) AllPendingMsgDests(ctx context.Context, arg AllPendingMsgDestsParams) ([]AllPendingMsgDestsRow, error) {
	rows, err := q.db.QueryContext(ctx, allPendingMsgDests, arg.AlertID, arg.ServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllPendingMsgDestsRow
	for rows.Next() {
		var i AllPendingMsgDestsRow
		if err := rows.Scan(
			&i.UserName,
			&i.CmDest,
			&i.NcName,
			&i.NcDest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authLinkAddAuthSubject = `-- name: AuthLinkAddAuthSubject :exec
INSERT INTO auth_subjects(provider_id, subject_id, user_id)
    VALUES ($1, $2, $3)
`

type AuthLinkAddAuthSubjectParams struct {
	ProviderID string
	SubjectID  string
	UserID     uuid.UUID
}

func (q *Queries) AuthLinkAddAuthSubject(ctx context.Context, arg AuthLinkAddAuthSubjectParams) error {
	_, err := q.db.ExecContext(ctx, authLinkAddAuthSubject, arg.ProviderID, arg.SubjectID, arg.UserID)
	return err
}

const authLinkAddReq = `-- name: AuthLinkAddReq :exec
INSERT INTO auth_link_requests(id, provider_id, subject_id, expires_at, metadata)
    VALUES ($1, $2, $3, $4, $5)
`

type AuthLinkAddReqParams struct {
	ID         uuid.UUID
	ProviderID string
	SubjectID  string
	ExpiresAt  time.Time
	Metadata   json.RawMessage
}

func (q *Queries) AuthLinkAddReq(ctx context.Context, arg AuthLinkAddReqParams) error {
	_, err := q.db.ExecContext(ctx, authLinkAddReq,
		arg.ID,
		arg.ProviderID,
		arg.SubjectID,
		arg.ExpiresAt,
		arg.Metadata,
	)
	return err
}

const authLinkMetadata = `-- name: AuthLinkMetadata :one
SELECT
    metadata
FROM
    auth_link_requests
WHERE
    id = $1
    AND expires_at > now()
`

func (q *Queries) AuthLinkMetadata(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, authLinkMetadata, id)
	var metadata json.RawMessage
	err := row.Scan(&metadata)
	return metadata, err
}

const authLinkUseReq = `-- name: AuthLinkUseReq :one
DELETE FROM auth_link_requests
WHERE id = $1
    AND expires_at > now()
RETURNING
    provider_id,
    subject_id
`

type AuthLinkUseReqRow struct {
	ProviderID string
	SubjectID  string
}

func (q *Queries) AuthLinkUseReq(ctx context.Context, id uuid.UUID) (AuthLinkUseReqRow, error) {
	row := q.db.QueryRowContext(ctx, authLinkUseReq, id)
	var i AuthLinkUseReqRow
	err := row.Scan(&i.ProviderID, &i.SubjectID)
	return i, err
}

const calSubAuthUser = `-- name: CalSubAuthUser :one
UPDATE
    user_calendar_subscriptions
SET
    last_access = now()
WHERE
    NOT disabled
    AND id = $1
    AND date_trunc('second', created_at) = $2
RETURNING
    user_id
`

type CalSubAuthUserParams struct {
	ID        uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CalSubAuthUser(ctx context.Context, arg CalSubAuthUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, calSubAuthUser, arg.ID, arg.CreatedAt)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const calSubRenderInfo = `-- name: CalSubRenderInfo :one
SELECT
    now()::timestamptz AS now,
    sub.schedule_id,
    sched.name AS schedule_name,
    sub.config,
    sub.user_id
FROM
    user_calendar_subscriptions sub
    JOIN schedules sched ON sched.id = schedule_id
WHERE
    sub.id = $1
`

type CalSubRenderInfoRow struct {
	Now          time.Time
	ScheduleID   uuid.UUID
	ScheduleName string
	Config       json.RawMessage
	UserID       uuid.UUID
}

func (q *Queries) CalSubRenderInfo(ctx context.Context, id uuid.UUID) (CalSubRenderInfoRow, error) {
	row := q.db.QueryRowContext(ctx, calSubRenderInfo, id)
	var i CalSubRenderInfoRow
	err := row.Scan(
		&i.Now,
		&i.ScheduleID,
		&i.ScheduleName,
		&i.Config,
		&i.UserID,
	)
	return i, err
}

const calSubUserNames = `-- name: CalSubUserNames :many
SELECT
    id,
    name
FROM
    users
WHERE
    id = ANY ($1::uuid[])
`

type CalSubUserNamesRow struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CalSubUserNames(ctx context.Context, dollar_1 []uuid.UUID) ([]CalSubUserNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, calSubUserNames, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CalSubUserNamesRow
	for rows.Next() {
		var i CalSubUserNamesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const connectionInfo = `-- name: ConnectionInfo :many
SELECT application_name AS NAME,
    COUNT(*)
FROM pg_stat_activity
WHERE datname = current_database()
GROUP BY NAME
`

type ConnectionInfoRow struct {
	Name  sql.NullString
	Count int64
}

func (q *Queries) ConnectionInfo(ctx context.Context) ([]ConnectionInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, connectionInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConnectionInfoRow
	for rows.Next() {
		var i ConnectionInfoRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodAdd = `-- name: ContactMethodAdd :exec
INSERT INTO user_contact_methods(id, name, dest, disabled, user_id, enable_status_updates)
    VALUES ($1, $2, $3, $4, $5, $6)
`

type ContactMethodAddParams struct {
	ID                  uuid.UUID
	Name                string
	Dest                NullDestV1
	Disabled            bool
	UserID              uuid.UUID
	EnableStatusUpdates bool
}

func (q *Queries) ContactMethodAdd(ctx context.Context, arg ContactMethodAddParams) error {
	_, err := q.db.ExecContext(ctx, contactMethodAdd,
		arg.ID,
		arg.Name,
		arg.Dest,
		arg.Disabled,
		arg.UserID,
		arg.EnableStatusUpdates,
	)
	return err
}

const contactMethodEnableDisable = `-- name: ContactMethodEnableDisable :one
UPDATE
    user_contact_methods
SET
    disabled = $2
WHERE
    dest = $1
RETURNING
    id
`

type ContactMethodEnableDisableParams struct {
	Dest     NullDestV1
	Disabled bool
}

func (q *Queries) ContactMethodEnableDisable(ctx context.Context, arg ContactMethodEnableDisableParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, contactMethodEnableDisable, arg.Dest, arg.Disabled)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const contactMethodFindAll = `-- name: ContactMethodFindAll :many
SELECT
    dest, disabled, enable_status_updates, id, last_test_verify_at, metadata, name, pending, type, user_id, value
FROM
    user_contact_methods
WHERE
    user_id = $1
`

func (q *Queries) ContactMethodFindAll(ctx context.Context, userID uuid.UUID) ([]UserContactMethod, error) {
	rows, err := q.db.QueryContext(ctx, contactMethodFindAll, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserContactMethod
	for rows.Next() {
		var i UserContactMethod
		if err := rows.Scan(
			&i.Dest,
			&i.Disabled,
			&i.EnableStatusUpdates,
			&i.ID,
			&i.LastTestVerifyAt,
			&i.Metadata,
			&i.Name,
			&i.Pending,
			&i.Type,
			&i.UserID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodFindMany = `-- name: ContactMethodFindMany :many
SELECT
    dest, disabled, enable_status_updates, id, last_test_verify_at, metadata, name, pending, type, user_id, value
FROM
    user_contact_methods
WHERE
    id = ANY ($1::uuid[])
`

func (q *Queries) ContactMethodFindMany(ctx context.Context, dollar_1 []uuid.UUID) ([]UserContactMethod, error) {
	rows, err := q.db.QueryContext(ctx, contactMethodFindMany, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserContactMethod
	for rows.Next() {
		var i UserContactMethod
		if err := rows.Scan(
			&i.Dest,
			&i.Disabled,
			&i.EnableStatusUpdates,
			&i.ID,
			&i.LastTestVerifyAt,
			&i.Metadata,
			&i.Name,
			&i.Pending,
			&i.Type,
			&i.UserID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodFindOneUpdate = `-- name: ContactMethodFindOneUpdate :one
SELECT
    dest, disabled, enable_status_updates, id, last_test_verify_at, metadata, name, pending, type, user_id, value
FROM
    user_contact_methods
WHERE
    id = $1
FOR UPDATE
`

func (q *Queries) ContactMethodFindOneUpdate(ctx context.Context, id uuid.UUID) (UserContactMethod, error) {
	row := q.db.QueryRowContext(ctx, contactMethodFindOneUpdate, id)
	var i UserContactMethod
	err := row.Scan(
		&i.Dest,
		&i.Disabled,
		&i.EnableStatusUpdates,
		&i.ID,
		&i.LastTestVerifyAt,
		&i.Metadata,
		&i.Name,
		&i.Pending,
		&i.Type,
		&i.UserID,
		&i.Value,
	)
	return i, err
}

const contactMethodFineOne = `-- name: ContactMethodFineOne :one
SELECT
    dest, disabled, enable_status_updates, id, last_test_verify_at, metadata, name, pending, type, user_id, value
FROM
    user_contact_methods
WHERE
    id = $1
`

func (q *Queries) ContactMethodFineOne(ctx context.Context, id uuid.UUID) (UserContactMethod, error) {
	row := q.db.QueryRowContext(ctx, contactMethodFineOne, id)
	var i UserContactMethod
	err := row.Scan(
		&i.Dest,
		&i.Disabled,
		&i.EnableStatusUpdates,
		&i.ID,
		&i.LastTestVerifyAt,
		&i.Metadata,
		&i.Name,
		&i.Pending,
		&i.Type,
		&i.UserID,
		&i.Value,
	)
	return i, err
}

const contactMethodLookupUserID = `-- name: ContactMethodLookupUserID :many
SELECT DISTINCT
    user_id
FROM
    user_contact_methods
WHERE
    id = ANY ($1::uuid[])
`

func (q *Queries) ContactMethodLookupUserID(ctx context.Context, dollar_1 []uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, contactMethodLookupUserID, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const contactMethodMetaDest = `-- name: ContactMethodMetaDest :one
SELECT
    coalesce(metadata, '{}'),
    now()::timestamptz AS now
FROM
    user_contact_methods
WHERE
    dest = $1
`

type ContactMethodMetaDestRow struct {
	Metadata json.RawMessage
	Now      time.Time
}

func (q *Queries) ContactMethodMetaDest(ctx context.Context, dest NullDestV1) (ContactMethodMetaDestRow, error) {
	row := q.db.QueryRowContext(ctx, contactMethodMetaDest, dest)
	var i ContactMethodMetaDestRow
	err := row.Scan(&i.Metadata, &i.Now)
	return i, err
}

const contactMethodUpdate = `-- name: ContactMethodUpdate :exec
UPDATE
    user_contact_methods
SET
    name = $2,
    disabled = $3,
    enable_status_updates = $4
WHERE
    id = $1
`

type ContactMethodUpdateParams struct {
	ID                  uuid.UUID
	Name                string
	Disabled            bool
	EnableStatusUpdates bool
}

func (q *Queries) ContactMethodUpdate(ctx context.Context, arg ContactMethodUpdateParams) error {
	_, err := q.db.ExecContext(ctx, contactMethodUpdate,
		arg.ID,
		arg.Name,
		arg.Disabled,
		arg.EnableStatusUpdates,
	)
	return err
}

const contactMethodUpdateMetaDest = `-- name: ContactMethodUpdateMetaDest :exec
UPDATE
    user_contact_methods
SET
    metadata = jsonb_set(jsonb_set(metadata, '{CarrierV1}', $2::jsonb), '{CarrierV1,UpdatedAt}',('"' || NOW()::timestamptz AT TIME ZONE 'UTC' || '"')::jsonb)
WHERE
    dest = $1
`

type ContactMethodUpdateMetaDestParams struct {
	Dest      NullDestV1
	CarrierV1 json.RawMessage
}

func (q *Queries) ContactMethodUpdateMetaDest(ctx context.Context, arg ContactMethodUpdateMetaDestParams) error {
	_, err := q.db.ExecContext(ctx, contactMethodUpdateMetaDest, arg.Dest, arg.CarrierV1)
	return err
}

const createCalSub = `-- name: CreateCalSub :one
INSERT INTO user_calendar_subscriptions(id, NAME, user_id, disabled, schedule_id, config)
    VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    created_at
`

type CreateCalSubParams struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
}

func (q *Queries) CreateCalSub(ctx context.Context, arg CreateCalSubParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, createCalSub,
		arg.ID,
		arg.Name,
		arg.UserID,
		arg.Disabled,
		arg.ScheduleID,
		arg.Config,
	)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const databaseInfo = `-- name: DatabaseInfo :one
SELECT db_id AS id,
    version()
FROM switchover_state
`

type DatabaseInfoRow struct {
	ID      uuid.UUID
	Version string
}

func (q *Queries) DatabaseInfo(ctx context.Context) (DatabaseInfoRow, error) {
	row := q.db.QueryRowContext(ctx, databaseInfo)
	var i DatabaseInfoRow
	err := row.Scan(&i.ID, &i.Version)
	return i, err
}

const deleteContactMethod = `-- name: DeleteContactMethod :exec
DELETE FROM user_contact_methods
WHERE id = ANY ($1::uuid[])
`

func (q *Queries) DeleteContactMethod(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteContactMethod, pq.Array(dollar_1))
	return err
}

const deleteManyCalSub = `-- name: DeleteManyCalSub :exec
DELETE FROM user_calendar_subscriptions
WHERE id = ANY ($1::uuid[])
    AND user_id = $2
`

type DeleteManyCalSubParams struct {
	Column1 []uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) DeleteManyCalSub(ctx context.Context, arg DeleteManyCalSubParams) error {
	_, err := q.db.ExecContext(ctx, deleteManyCalSub, pq.Array(arg.Column1), arg.UserID)
	return err
}

const disableChangeLogTriggers = `-- name: DisableChangeLogTriggers :exec
UPDATE switchover_state
SET current_state = 'idle'
WHERE current_state = 'in_progress'
`

func (q *Queries) DisableChangeLogTriggers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, disableChangeLogTriggers)
	return err
}

const ePStepActionsAddAction = `-- name: EPStepActionsAddAction :exec
INSERT INTO escalation_policy_actions(escalation_policy_step_id, user_id, schedule_id, rotation_id, channel_id)
    VALUES ($1, $2, $3, $4, $5)
`

type EPStepActionsAddActionParams struct {
	EscalationPolicyStepID uuid.UUID
	UserID                 uuid.NullUUID
	ScheduleID             uuid.NullUUID
	RotationID             uuid.NullUUID
	ChannelID              uuid.NullUUID
}

func (q *Queries) EPStepActionsAddAction(ctx context.Context, arg EPStepActionsAddActionParams) error {
	_, err := q.db.ExecContext(ctx, ePStepActionsAddAction,
		arg.EscalationPolicyStepID,
		arg.UserID,
		arg.ScheduleID,
		arg.RotationID,
		arg.ChannelID,
	)
	return err
}

const ePStepActionsByStepId = `-- name: EPStepActionsByStepId :many
SELECT
    a.user_id,
    a.schedule_id,
    a.rotation_id,
    ch.dest
FROM
    escalation_policy_actions a
    LEFT JOIN notification_channels ch ON a.channel_id = ch.id
WHERE
    a.escalation_policy_step_id = $1
`

type EPStepActionsByStepIdRow struct {
	UserID     uuid.NullUUID
	ScheduleID uuid.NullUUID
	RotationID uuid.NullUUID
	Dest       NullDestV1
}

func (q *Queries) EPStepActionsByStepId(ctx context.Context, escalationPolicyStepID uuid.UUID) ([]EPStepActionsByStepIdRow, error) {
	rows, err := q.db.QueryContext(ctx, ePStepActionsByStepId, escalationPolicyStepID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EPStepActionsByStepIdRow
	for rows.Next() {
		var i EPStepActionsByStepIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.ScheduleID,
			&i.RotationID,
			&i.Dest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ePStepActionsDeleteAction = `-- name: EPStepActionsDeleteAction :exec
DELETE FROM escalation_policy_actions
WHERE escalation_policy_step_id = $1
    AND (user_id = $2
        OR schedule_id = $3
        OR rotation_id = $4
        OR channel_id = $5)
`

type EPStepActionsDeleteActionParams struct {
	EscalationPolicyStepID uuid.UUID
	UserID                 uuid.NullUUID
	ScheduleID             uuid.NullUUID
	RotationID             uuid.NullUUID
	ChannelID              uuid.NullUUID
}

func (q *Queries) EPStepActionsDeleteAction(ctx context.Context, arg EPStepActionsDeleteActionParams) error {
	_, err := q.db.ExecContext(ctx, ePStepActionsDeleteAction,
		arg.EscalationPolicyStepID,
		arg.UserID,
		arg.ScheduleID,
		arg.RotationID,
		arg.ChannelID,
	)
	return err
}

const enableChangeLogTriggers = `-- name: EnableChangeLogTriggers :exec
UPDATE switchover_state
SET current_state = 'in_progress'
WHERE current_state = 'idle'
`

func (q *Queries) EnableChangeLogTriggers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, enableChangeLogTriggers)
	return err
}

const engineGetSignalParams = `-- name: EngineGetSignalParams :one
SELECT
    params
FROM
    pending_signals
WHERE
    message_id = $1
`

// Get a pending signal's rendered params.
func (q *Queries) EngineGetSignalParams(ctx context.Context, messageID uuid.NullUUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, engineGetSignalParams, messageID)
	var params json.RawMessage
	err := row.Scan(&params)
	return params, err
}

const engineIsKnownDest = `-- name: EngineIsKnownDest :one
SELECT
    EXISTS (
        SELECT
        FROM
            user_contact_methods uc
        WHERE
            uc.dest = $1
            AND uc.disabled = FALSE)
    OR EXISTS (
        SELECT
        FROM
            notification_channels nc
        WHERE
            nc.dest = $1)
`

// Check if a destination is known in user_contact_methods or notification_channels table.
func (q *Queries) EngineIsKnownDest(ctx context.Context, dest NullDestV1) (sql.NullBool, error) {
	row := q.db.QueryRowContext(ctx, engineIsKnownDest, dest)
	var column_1 sql.NullBool
	err := row.Scan(&column_1)
	return column_1, err
}

const findManyCalSubByUser = `-- name: FindManyCalSubByUser :many
SELECT
    id,
    NAME,
    user_id,
    disabled,
    schedule_id,
    config,
    last_access
FROM
    user_calendar_subscriptions
WHERE
    user_id = $1
`

type FindManyCalSubByUserRow struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
	LastAccess sql.NullTime
}

func (q *Queries) FindManyCalSubByUser(ctx context.Context, userID uuid.UUID) ([]FindManyCalSubByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, findManyCalSubByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindManyCalSubByUserRow
	for rows.Next() {
		var i FindManyCalSubByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.Disabled,
			&i.ScheduleID,
			&i.Config,
			&i.LastAccess,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOneCalSub = `-- name: FindOneCalSub :one
SELECT
    id,
    NAME,
    user_id,
    disabled,
    schedule_id,
    config,
    last_access
FROM
    user_calendar_subscriptions
WHERE
    id = $1
`

type FindOneCalSubRow struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
	LastAccess sql.NullTime
}

func (q *Queries) FindOneCalSub(ctx context.Context, id uuid.UUID) (FindOneCalSubRow, error) {
	row := q.db.QueryRowContext(ctx, findOneCalSub, id)
	var i FindOneCalSubRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Disabled,
		&i.ScheduleID,
		&i.Config,
		&i.LastAccess,
	)
	return i, err
}

const findOneCalSubForUpdate = `-- name: FindOneCalSubForUpdate :one
SELECT
    id,
    NAME,
    user_id,
    disabled,
    schedule_id,
    config,
    last_access
FROM
    user_calendar_subscriptions
WHERE
    id = $1
FOR UPDATE
`

type FindOneCalSubForUpdateRow struct {
	ID         uuid.UUID
	Name       string
	UserID     uuid.UUID
	Disabled   bool
	ScheduleID uuid.UUID
	Config     json.RawMessage
	LastAccess sql.NullTime
}

func (q *Queries) FindOneCalSubForUpdate(ctx context.Context, id uuid.UUID) (FindOneCalSubForUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, findOneCalSubForUpdate, id)
	var i FindOneCalSubForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.Disabled,
		&i.ScheduleID,
		&i.Config,
		&i.LastAccess,
	)
	return i, err
}

const foreignKeyRefs = `-- name: ForeignKeyRefs :many
SELECT src.relname::text,
    dst.relname::text
FROM pg_catalog.pg_constraint con
    JOIN pg_catalog.pg_namespace ns ON ns.nspname = 'public'
    AND ns.oid = con.connamespace
    JOIN pg_catalog.pg_class src ON src.oid = con.conrelid
    JOIN pg_catalog.pg_class dst ON dst.oid = con.confrelid
WHERE con.contype = 'f'
    AND NOT con.condeferrable
`

type ForeignKeyRefsRow struct {
	SrcRelname string
	DstRelname string
}

func (q *Queries) ForeignKeyRefs(ctx context.Context) ([]ForeignKeyRefsRow, error) {
	rows, err := q.db.QueryContext(ctx, foreignKeyRefs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForeignKeyRefsRow
	for rows.Next() {
		var i ForeignKeyRefsRow
		if err := rows.Scan(&i.SrcRelname, &i.DstRelname); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gQLUserOnCallOverview = `-- name: GQLUserOnCallOverview :many
SELECT
    svc.id AS service_id,
    svc.name AS service_name,
    ep.id AS policy_id,
    ep.name AS policy_name,
    step.step_number
FROM
    ep_step_on_call_users oc
    JOIN escalation_policy_steps step ON step.id = oc.ep_step_id
    JOIN escalation_policies ep ON ep.id = step.escalation_policy_id
    JOIN services svc ON svc.escalation_policy_id = ep.id
WHERE
    oc.user_id = $1
`

type GQLUserOnCallOverviewRow struct {
	ServiceID   uuid.UUID
	ServiceName string
	PolicyID    uuid.UUID
	PolicyName  string
	StepNumber  int32
}

func (q *Queries) GQLUserOnCallOverview(ctx context.Context, userID uuid.UUID) ([]GQLUserOnCallOverviewRow, error) {
	rows, err := q.db.QueryContext(ctx, gQLUserOnCallOverview, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GQLUserOnCallOverviewRow
	for rows.Next() {
		var i GQLUserOnCallOverviewRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.ServiceName,
			&i.PolicyID,
			&i.PolicyName,
			&i.StepNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const intKeyCreate = `-- name: IntKeyCreate :exec
INSERT INTO integration_keys(id, name, type, service_id, external_system_name)
    VALUES ($1, $2, $3, $4, $5)
`

type IntKeyCreateParams struct {
	ID                 uuid.UUID
	Name               string
	Type               EnumIntegrationKeysType
	ServiceID          uuid.UUID
	ExternalSystemName sql.NullString
}

func (q *Queries) IntKeyCreate(ctx context.Context, arg IntKeyCreateParams) error {
	_, err := q.db.ExecContext(ctx, intKeyCreate,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.ServiceID,
		arg.ExternalSystemName,
	)
	return err
}

const intKeyDelete = `-- name: IntKeyDelete :exec
DELETE FROM integration_keys
WHERE id = ANY ($1::uuid[])
`

func (q *Queries) IntKeyDelete(ctx context.Context, ids []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, intKeyDelete, pq.Array(ids))
	return err
}

const intKeyDeleteConfig = `-- name: IntKeyDeleteConfig :exec
DELETE FROM uik_config
WHERE id = $1
`

func (q *Queries) IntKeyDeleteConfig(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, intKeyDeleteConfig, id)
	return err
}

const intKeyDeleteSecondaryToken = `-- name: IntKeyDeleteSecondaryToken :exec
UPDATE
    uik_config
SET
    secondary_token = NULL,
    secondary_token_hint = NULL
WHERE
    id = $1
`

func (q *Queries) IntKeyDeleteSecondaryToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, intKeyDeleteSecondaryToken, id)
	return err
}

const intKeyFindByService = `-- name: IntKeyFindByService :many
SELECT
    id,
    name,
    type,
    service_id,
    external_system_name
FROM
    integration_keys
WHERE
    service_id = $1
`

type IntKeyFindByServiceRow struct {
	ID                 uuid.UUID
	Name               string
	Type               EnumIntegrationKeysType
	ServiceID          uuid.UUID
	ExternalSystemName sql.NullString
}

func (q *Queries) IntKeyFindByService(ctx context.Context, serviceID uuid.UUID) ([]IntKeyFindByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, intKeyFindByService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IntKeyFindByServiceRow
	for rows.Next() {
		var i IntKeyFindByServiceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ServiceID,
			&i.ExternalSystemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const intKeyFindOne = `-- name: IntKeyFindOne :one
SELECT
    id,
    name,
    type,
    service_id,
    external_system_name
FROM
    integration_keys
WHERE
    id = $1
`

type IntKeyFindOneRow struct {
	ID                 uuid.UUID
	Name               string
	Type               EnumIntegrationKeysType
	ServiceID          uuid.UUID
	ExternalSystemName sql.NullString
}

func (q *Queries) IntKeyFindOne(ctx context.Context, id uuid.UUID) (IntKeyFindOneRow, error) {
	row := q.db.QueryRowContext(ctx, intKeyFindOne, id)
	var i IntKeyFindOneRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ServiceID,
		&i.ExternalSystemName,
	)
	return i, err
}

const intKeyGetConfig = `-- name: IntKeyGetConfig :one
SELECT
    config
FROM
    uik_config
WHERE
    id = $1
FOR UPDATE
`

func (q *Queries) IntKeyGetConfig(ctx context.Context, id uuid.UUID) (UIKConfig, error) {
	row := q.db.QueryRowContext(ctx, intKeyGetConfig, id)
	var config UIKConfig
	err := row.Scan(&config)
	return config, err
}

const intKeyGetServiceID = `-- name: IntKeyGetServiceID :one
SELECT
    service_id
FROM
    integration_keys
WHERE
    id = $1
    AND type = $2
`

type IntKeyGetServiceIDParams struct {
	ID   uuid.UUID
	Type EnumIntegrationKeysType
}

func (q *Queries) IntKeyGetServiceID(ctx context.Context, arg IntKeyGetServiceIDParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, intKeyGetServiceID, arg.ID, arg.Type)
	var service_id uuid.UUID
	err := row.Scan(&service_id)
	return service_id, err
}

const intKeyGetType = `-- name: IntKeyGetType :one
SELECT
    type
FROM
    integration_keys
WHERE
    id = $1
`

func (q *Queries) IntKeyGetType(ctx context.Context, id uuid.UUID) (EnumIntegrationKeysType, error) {
	row := q.db.QueryRowContext(ctx, intKeyGetType, id)
	var type_ EnumIntegrationKeysType
	err := row.Scan(&type_)
	return type_, err
}

const intKeyInsertSignalMessage = `-- name: IntKeyInsertSignalMessage :exec
INSERT INTO pending_signals(dest_id, service_id, params)
    VALUES ($1, $2, $3)
`

type IntKeyInsertSignalMessageParams struct {
	DestID    uuid.UUID
	ServiceID uuid.UUID
	Params    json.RawMessage
}

func (q *Queries) IntKeyInsertSignalMessage(ctx context.Context, arg IntKeyInsertSignalMessageParams) error {
	_, err := q.db.ExecContext(ctx, intKeyInsertSignalMessage, arg.DestID, arg.ServiceID, arg.Params)
	return err
}

const intKeyPromoteSecondary = `-- name: IntKeyPromoteSecondary :one
UPDATE
    uik_config
SET
    primary_token = secondary_token,
    primary_token_hint = secondary_token_hint,
    secondary_token = NULL,
    secondary_token_hint = NULL
WHERE
    id = $1
RETURNING
    primary_token_hint
`

func (q *Queries) IntKeyPromoteSecondary(ctx context.Context, id uuid.UUID) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, intKeyPromoteSecondary, id)
	var primary_token_hint sql.NullString
	err := row.Scan(&primary_token_hint)
	return primary_token_hint, err
}

const intKeySetConfig = `-- name: IntKeySetConfig :exec
INSERT INTO uik_config(id, config)
    VALUES ($1, $2)
ON CONFLICT (id)
    DO UPDATE SET
        config = $2
`

type IntKeySetConfigParams struct {
	ID     uuid.UUID
	Config UIKConfig
}

func (q *Queries) IntKeySetConfig(ctx context.Context, arg IntKeySetConfigParams) error {
	_, err := q.db.ExecContext(ctx, intKeySetConfig, arg.ID, arg.Config)
	return err
}

const intKeySetPrimaryToken = `-- name: IntKeySetPrimaryToken :one
UPDATE
    uik_config
SET
    primary_token = $2,
    primary_token_hint = $3
WHERE
    id = $1
    AND primary_token IS NULL
RETURNING
    id
`

type IntKeySetPrimaryTokenParams struct {
	ID               uuid.UUID
	PrimaryToken     uuid.NullUUID
	PrimaryTokenHint sql.NullString
}

func (q *Queries) IntKeySetPrimaryToken(ctx context.Context, arg IntKeySetPrimaryTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, intKeySetPrimaryToken, arg.ID, arg.PrimaryToken, arg.PrimaryTokenHint)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const intKeySetSecondaryToken = `-- name: IntKeySetSecondaryToken :one
UPDATE
    uik_config
SET
    secondary_token = $2,
    secondary_token_hint = $3
WHERE
    id = $1
    AND secondary_token IS NULL
    AND primary_token IS NOT NULL
RETURNING
    id
`

type IntKeySetSecondaryTokenParams struct {
	ID                 uuid.UUID
	SecondaryToken     uuid.NullUUID
	SecondaryTokenHint sql.NullString
}

func (q *Queries) IntKeySetSecondaryToken(ctx context.Context, arg IntKeySetSecondaryTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, intKeySetSecondaryToken, arg.ID, arg.SecondaryToken, arg.SecondaryTokenHint)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const intKeyTokenHints = `-- name: IntKeyTokenHints :one
SELECT
    primary_token_hint,
    secondary_token_hint
FROM
    uik_config
WHERE
    id = $1
`

type IntKeyTokenHintsRow struct {
	PrimaryTokenHint   sql.NullString
	SecondaryTokenHint sql.NullString
}

func (q *Queries) IntKeyTokenHints(ctx context.Context, id uuid.UUID) (IntKeyTokenHintsRow, error) {
	row := q.db.QueryRowContext(ctx, intKeyTokenHints, id)
	var i IntKeyTokenHintsRow
	err := row.Scan(&i.PrimaryTokenHint, &i.SecondaryTokenHint)
	return i, err
}

const intKeyUIKValidateService = `-- name: IntKeyUIKValidateService :one
SELECT
    k.service_id
FROM
    uik_config c
    JOIN integration_keys k ON k.id = c.id
WHERE
    c.id = $1
    AND k.type = 'universal'
    AND (c.primary_token = $2
        OR c.secondary_token = $2)
`

type IntKeyUIKValidateServiceParams struct {
	KeyID   uuid.UUID
	TokenID uuid.NullUUID
}

func (q *Queries) IntKeyUIKValidateService(ctx context.Context, arg IntKeyUIKValidateServiceParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, intKeyUIKValidateService, arg.KeyID, arg.TokenID)
	var service_id uuid.UUID
	err := row.Scan(&service_id)
	return service_id, err
}

const labelDeleteKeyByTarget = `-- name: LabelDeleteKeyByTarget :exec
DELETE FROM labels
WHERE key = $1
    AND tgt_service_id = $2
`

type LabelDeleteKeyByTargetParams struct {
	Key          string
	TgtServiceID uuid.UUID
}

func (q *Queries) LabelDeleteKeyByTarget(ctx context.Context, arg LabelDeleteKeyByTargetParams) error {
	_, err := q.db.ExecContext(ctx, labelDeleteKeyByTarget, arg.Key, arg.TgtServiceID)
	return err
}

const labelFindAllByTarget = `-- name: LabelFindAllByTarget :many
SELECT
    key,
    value
FROM
    labels
WHERE
    tgt_service_id = $1
`

type LabelFindAllByTargetRow struct {
	Key   string
	Value string
}

func (q *Queries) LabelFindAllByTarget(ctx context.Context, tgtServiceID uuid.UUID) ([]LabelFindAllByTargetRow, error) {
	rows, err := q.db.QueryContext(ctx, labelFindAllByTarget, tgtServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LabelFindAllByTargetRow
	for rows.Next() {
		var i LabelFindAllByTargetRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const labelSetByTarget = `-- name: LabelSetByTarget :exec
INSERT INTO labels(key, value, tgt_service_id)
    VALUES ($1, $2, $3)
ON CONFLICT (key, tgt_service_id)
    DO UPDATE SET
        value = $2
`

type LabelSetByTargetParams struct {
	Key          string
	Value        string
	TgtServiceID uuid.UUID
}

func (q *Queries) LabelSetByTarget(ctx context.Context, arg LabelSetByTargetParams) error {
	_, err := q.db.ExecContext(ctx, labelSetByTarget, arg.Key, arg.Value, arg.TgtServiceID)
	return err
}

const labelUniqueKeys = `-- name: LabelUniqueKeys :many
SELECT DISTINCT
    key
FROM
    labels
`

func (q *Queries) LabelUniqueKeys(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, labelUniqueKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lastLogID = `-- name: LastLogID :one
SELECT COALESCE(MAX(id), 0)::bigint
FROM switchover_log
`

func (q *Queries) LastLogID(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, lastLogID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listCheckConstraints = `-- name: ListCheckConstraints :many
SELECT
    n.nspname::text AS schema_name,
    c.relname::text AS table_name,
    cc.conname::text AS constraint_name,
    pg_get_constraintdef(cc.oid) AS check_clause
FROM
    pg_catalog.pg_constraint cc
    JOIN pg_catalog.pg_class c ON cc.conrelid = c.oid
    JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE
    cc.contype = 'c'
ORDER BY
    n.nspname,
    c.relname,
    cc.conname
`

type ListCheckConstraintsRow struct {
	SchemaName     string
	TableName      string
	ConstraintName string
	CheckClause    string
}

func (q *Queries) ListCheckConstraints(ctx context.Context) ([]ListCheckConstraintsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCheckConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCheckConstraintsRow
	for rows.Next() {
		var i ListCheckConstraintsRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ConstraintName,
			&i.CheckClause,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listColumns = `-- name: ListColumns :many
SELECT
    n.nspname::text AS schema_name,
    c.relname::text AS table_name,
    a.attnum AS column_number,
    a.attname::text AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) AS column_type,
    coalesce(pg_get_expr(d.adbin, d.adrelid), '')::text AS column_default,
    a.attnotnull AS not_null
FROM
    pg_catalog.pg_attribute a
    JOIN pg_catalog.pg_class c ON a.attnum > 0
        AND a.attrelid = c.oid
    JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    LEFT JOIN pg_catalog.pg_attrdef d ON a.attrelid = d.adrelid
        AND a.attnum = d.adnum
WHERE
    n.nspname NOT IN ('pg_catalog', 'information_schema')
    AND c.relkind = 'r'
    AND NOT a.attisdropped
ORDER BY
    n.nspname,
    c.relname,
    a.attname
`

type ListColumnsRow struct {
	SchemaName    string
	TableName     string
	ColumnNumber  int16
	ColumnName    string
	ColumnType    string
	ColumnDefault string
	NotNull       bool
}

func (q *Queries) ListColumns(ctx context.Context) ([]ListColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, listColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListColumnsRow
	for rows.Next() {
		var i ListColumnsRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ColumnNumber,
			&i.ColumnName,
			&i.ColumnType,
			&i.ColumnDefault,
			&i.NotNull,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConstraints = `-- name: ListConstraints :many
SELECT
    n.nspname::text AS schema_name,
    t.relname::text AS table_name,
    c.conname::text AS constraint_name,
    pg_catalog.pg_get_constraintdef(c.oid, TRUE) AS constraint_definition
FROM
    pg_catalog.pg_constraint c
    JOIN pg_catalog.pg_class t ON c.conrelid = t.oid
    JOIN pg_catalog.pg_namespace n ON n.oid = t.relnamespace
WHERE
    t.relkind = 'r'
    AND n.nspname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    n.nspname,
    t.relname,
    c.conname
`

type ListConstraintsRow struct {
	SchemaName           string
	TableName            string
	ConstraintName       string
	ConstraintDefinition string
}

func (q *Queries) ListConstraints(ctx context.Context) ([]ListConstraintsRow, error) {
	rows, err := q.db.QueryContext(ctx, listConstraints)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConstraintsRow
	for rows.Next() {
		var i ListConstraintsRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ConstraintName,
			&i.ConstraintDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnums = `-- name: ListEnums :many
SELECT
    n.nspname::text AS schema_name,
    t.typname::text AS enum_name,
    string_agg(e.enumlabel, ',' ORDER BY e.enumlabel) AS enum_values
FROM
    pg_catalog.pg_type t
    JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
    JOIN pg_catalog.pg_enum e ON e.enumtypid = t.oid
WHERE (t.typrelid = 0
    OR (
        SELECT
            c.relkind = 'c'
        FROM
            pg_catalog.pg_class c
        WHERE
            c.oid = t.typrelid))
AND NOT EXISTS (
    SELECT
        1
    FROM
        pg_catalog.pg_type el
    WHERE
        el.oid = t.typelem
        AND el.typarray = t.oid)
AND n.nspname NOT IN ('pg_catalog', 'information_schema')
GROUP BY
    n.nspname,
    t.typname
ORDER BY
    n.nspname,
    t.typname
`

type ListEnumsRow struct {
	SchemaName string
	EnumName   string
	EnumValues []byte
}

func (q *Queries) ListEnums(ctx context.Context) ([]ListEnumsRow, error) {
	rows, err := q.db.QueryContext(ctx, listEnums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnumsRow
	for rows.Next() {
		var i ListEnumsRow
		if err := rows.Scan(&i.SchemaName, &i.EnumName, &i.EnumValues); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExtensions = `-- name: ListExtensions :many
SELECT
    extname::text AS ext_name,
    n.nspname::text AS schema_name
FROM
    pg_catalog.pg_extension e
    JOIN pg_catalog.pg_namespace n ON n.oid = e.extnamespace
        AND n.nspname != 'pg_catalog'
    ORDER BY
        n.nspname,
        extname
`

type ListExtensionsRow struct {
	ExtName    string
	SchemaName string
}

func (q *Queries) ListExtensions(ctx context.Context) ([]ListExtensionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listExtensions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExtensionsRow
	for rows.Next() {
		var i ListExtensionsRow
		if err := rows.Scan(&i.ExtName, &i.SchemaName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFunctions = `-- name: ListFunctions :many
SELECT
    n.nspname::text AS schema_name,
    p.proname::text AS function_name,
    pg_get_functiondef(p.oid) AS func_def
FROM
    pg_catalog.pg_proc p
    JOIN pg_catalog.pg_namespace n ON p.pronamespace = n.oid
    LEFT JOIN pg_catalog.pg_depend d ON p.oid = d.objid
        AND d.deptype = 'e'
    LEFT JOIN pg_catalog.pg_extension e ON d.refobjid = e.oid
WHERE
    n.nspname NOT IN ('pg_catalog', 'information_schema')
    AND p.prokind = 'f'
    AND d.objid IS NULL
ORDER BY
    n.nspname,
    p.proname
`

type ListFunctionsRow struct {
	SchemaName   string
	FunctionName string
	FuncDef      string
}

func (q *Queries) ListFunctions(ctx context.Context) ([]ListFunctionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFunctions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFunctionsRow
	for rows.Next() {
		var i ListFunctionsRow
		if err := rows.Scan(&i.SchemaName, &i.FunctionName, &i.FuncDef); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIndexes = `-- name: ListIndexes :many
SELECT
    n.nspname::text AS schema_name,
    t.relname::text AS table_name,
    i.indexname::text AS index_name,
    i.indexdef::text AS index_definition
FROM
    pg_catalog.pg_indexes i
    JOIN pg_catalog.pg_class t ON t.relname = i.tablename
    JOIN pg_catalog.pg_namespace n ON n.oid = t.relnamespace
WHERE
    n.nspname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    n.nspname,
    t.relname,
    i.indexname
`

type ListIndexesRow struct {
	SchemaName      string
	TableName       string
	IndexName       string
	IndexDefinition string
}

func (q *Queries) ListIndexes(ctx context.Context) ([]ListIndexesRow, error) {
	rows, err := q.db.QueryContext(ctx, listIndexes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIndexesRow
	for rows.Next() {
		var i ListIndexesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.IndexName,
			&i.IndexDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSequences = `-- name: ListSequences :many
SELECT
    n.nspname::text AS schema_name,
    s.relname::text AS sequence_name,
    seq.start_value,
    seq.increment_by AS increment,
    seq.min_value AS min_value,
    seq.max_value AS max_value,
    seq.cache_size AS
    CACHE,
    coalesce((
        SELECT
            tn.nspname::text
        FROM pg_catalog.pg_namespace tn
        WHERE
            tn.oid = tc.relnamespace), '')::text AS table_schema,
    coalesce(tc.relname, '')::text AS table_name,
    coalesce(a.attname, '')::text AS column_name
FROM
    pg_catalog.pg_class s
    JOIN pg_catalog.pg_namespace n ON s.relnamespace = n.oid
    JOIN pg_catalog.pg_sequences seq ON n.nspname = seq.schemaname
        AND s.relname = seq.sequencename
    LEFT JOIN pg_catalog.pg_depend d ON s.oid = d.objid
        AND d.deptype = 'a'
    LEFT JOIN pg_catalog.pg_attribute a ON a.attnum = d.refobjsubid
        AND a.attrelid = d.refobjid
    LEFT JOIN pg_catalog.pg_class tc ON tc.oid = d.refobjid
WHERE
    s.relkind = 'S'
ORDER BY
    n.nspname,
    s.relname
`

type ListSequencesRow struct {
	SchemaName   string
	SequenceName string
	StartValue   sql.NullInt64
	Increment    sql.NullInt64
	MinValue     sql.NullInt64
	MaxValue     sql.NullInt64
	Cache        sql.NullInt64
	TableSchema  string
	TableName    string
	ColumnName   string
}

func (q *Queries) ListSequences(ctx context.Context) ([]ListSequencesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSequences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSequencesRow
	for rows.Next() {
		var i ListSequencesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.SequenceName,
			&i.StartValue,
			&i.Increment,
			&i.MinValue,
			&i.MaxValue,
			&i.Cache,
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTriggers = `-- name: ListTriggers :many
SELECT
    n.nspname::text AS schema_name,
    t.relname::text AS table_name,
    trg.tgname::text AS trigger_name,
    pg_catalog.pg_get_triggerdef(trg.oid) AS trigger_definition
FROM
    pg_catalog.pg_trigger trg
    JOIN pg_catalog.pg_class t ON t.oid = trg.tgrelid
    JOIN pg_catalog.pg_namespace n ON n.oid = t.relnamespace
WHERE
    NOT trg.tgisinternal
    AND n.nspname NOT IN ('pg_catalog', 'information_schema')
ORDER BY
    n.nspname,
    t.relname,
    trg.tgname
`

type ListTriggersRow struct {
	SchemaName        string
	TableName         string
	TriggerName       string
	TriggerDefinition string
}

func (q *Queries) ListTriggers(ctx context.Context) ([]ListTriggersRow, error) {
	rows, err := q.db.QueryContext(ctx, listTriggers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTriggersRow
	for rows.Next() {
		var i ListTriggersRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.TriggerName,
			&i.TriggerDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockOneAlertService = `-- name: LockOneAlertService :one
SELECT
    maintenance_expires_at NOTNULL::bool AS is_maint_mode,
    alerts.status
FROM
    services svc
    JOIN alerts ON alerts.service_id = svc.id
WHERE
    alerts.id = $1
FOR UPDATE
`

type LockOneAlertServiceRow struct {
	IsMaintMode bool
	Status      EnumAlertStatus
}

func (q *Queries) LockOneAlertService(ctx context.Context, id int64) (LockOneAlertServiceRow, error) {
	row := q.db.QueryRowContext(ctx, lockOneAlertService, id)
	var i LockOneAlertServiceRow
	err := row.Scan(&i.IsMaintMode, &i.Status)
	return i, err
}

const logEvents = `-- name: LogEvents :many
SELECT id,
    TIMESTAMP,
    DATA
FROM switchover_log
WHERE id > $1
ORDER BY id ASC
LIMIT 100
`

type LogEventsRow struct {
	ID        int64
	Timestamp time.Time
	Data      json.RawMessage
}

func (q *Queries) LogEvents(ctx context.Context, id int64) ([]LogEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, logEvents, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogEventsRow
	for rows.Next() {
		var i LogEventsRow
		if err := rows.Scan(&i.ID, &i.Timestamp, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const messageMgrGetPending = `-- name: MessageMgrGetPending :many
SELECT
    msg.id,
    msg.message_type,
    cm.id AS cm_id,
    chan.id AS chan_id,
    coalesce(cm.dest, chan.dest) AS dest,
    msg.alert_id,
    msg.alert_log_id,
    msg.user_verification_code_id,
    cm.user_id,
    msg.service_id,
    msg.created_at,
    msg.sent_at,
    msg.status_alert_ids,
    msg.schedule_id
FROM
    outgoing_messages msg
    LEFT JOIN user_contact_methods cm ON cm.id = msg.contact_method_id
    LEFT JOIN notification_channels chan ON chan.id = msg.channel_id
WHERE
    sent_at >= $1
    OR last_status = 'pending'
    AND (msg.contact_method_id ISNULL
        OR msg.message_type = 'verification_message'
        OR NOT cm.disabled)
`

type MessageMgrGetPendingRow struct {
	ID                     uuid.UUID
	MessageType            EnumOutgoingMessagesType
	CmID                   uuid.NullUUID
	ChanID                 uuid.NullUUID
	Dest                   NullDestV1
	AlertID                sql.NullInt64
	AlertLogID             sql.NullInt64
	UserVerificationCodeID uuid.NullUUID
	UserID                 uuid.NullUUID
	ServiceID              uuid.NullUUID
	CreatedAt              time.Time
	SentAt                 sql.NullTime
	StatusAlertIds         []int64
	ScheduleID             uuid.NullUUID
}

func (q *Queries) MessageMgrGetPending(ctx context.Context, sentAt sql.NullTime) ([]MessageMgrGetPendingRow, error) {
	rows, err := q.db.QueryContext(ctx, messageMgrGetPending, sentAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageMgrGetPendingRow
	for rows.Next() {
		var i MessageMgrGetPendingRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageType,
			&i.CmID,
			&i.ChanID,
			&i.Dest,
			&i.AlertID,
			&i.AlertLogID,
			&i.UserVerificationCodeID,
			&i.UserID,
			&i.ServiceID,
			&i.CreatedAt,
			&i.SentAt,
			pq.Array(&i.StatusAlertIds),
			&i.ScheduleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nfyLastMessageStatus = `-- name: NfyLastMessageStatus :one
SELECT
    om.alert_id, om.alert_log_id, om.channel_id, om.contact_method_id, om.created_at, om.cycle_id, om.escalation_policy_id, om.fired_at, om.id, om.last_status, om.last_status_at, om.message_type, om.next_retry_at, om.provider_msg_id, om.provider_seq, om.retry_count, om.schedule_id, om.sending_deadline, om.sent_at, om.service_id, om.src_value, om.status_alert_ids, om.status_details, om.user_id, om.user_verification_code_id,
    cm.dest AS cm_dest,
    ch.dest AS ch_dest
FROM
    outgoing_messages om
    LEFT JOIN notification_channels ch ON om.channel_id = ch.id
    LEFT JOIN user_contact_methods cm ON om.contact_method_id = cm.id
WHERE
    message_type = $1
    AND contact_method_id = $2
    AND om.created_at >= $3
`

type NfyLastMessageStatusParams struct {
	MessageType     EnumOutgoingMessagesType
	ContactMethodID uuid.NullUUID
	CreatedAt       time.Time
}

type NfyLastMessageStatusRow struct {
	OutgoingMessage OutgoingMessage
	CmDest          NullDestV1
	ChDest          NullDestV1
}

func (q *Queries) NfyLastMessageStatus(ctx context.Context, arg NfyLastMessageStatusParams) (NfyLastMessageStatusRow, error) {
	row := q.db.QueryRowContext(ctx, nfyLastMessageStatus, arg.MessageType, arg.ContactMethodID, arg.CreatedAt)
	var i NfyLastMessageStatusRow
	err := row.Scan(
		&i.OutgoingMessage.AlertID,
		&i.OutgoingMessage.AlertLogID,
		&i.OutgoingMessage.ChannelID,
		&i.OutgoingMessage.ContactMethodID,
		&i.OutgoingMessage.CreatedAt,
		&i.OutgoingMessage.CycleID,
		&i.OutgoingMessage.EscalationPolicyID,
		&i.OutgoingMessage.FiredAt,
		&i.OutgoingMessage.ID,
		&i.OutgoingMessage.LastStatus,
		&i.OutgoingMessage.LastStatusAt,
		&i.OutgoingMessage.MessageType,
		&i.OutgoingMessage.NextRetryAt,
		&i.OutgoingMessage.ProviderMsgID,
		&i.OutgoingMessage.ProviderSeq,
		&i.OutgoingMessage.RetryCount,
		&i.OutgoingMessage.ScheduleID,
		&i.OutgoingMessage.SendingDeadline,
		&i.OutgoingMessage.SentAt,
		&i.OutgoingMessage.ServiceID,
		&i.OutgoingMessage.SrcValue,
		pq.Array(&i.OutgoingMessage.StatusAlertIds),
		&i.OutgoingMessage.StatusDetails,
		&i.OutgoingMessage.UserID,
		&i.OutgoingMessage.UserVerificationCodeID,
		&i.CmDest,
		&i.ChDest,
	)
	return i, err
}

const nfyManyMessageStatus = `-- name: NfyManyMessageStatus :many
SELECT
    om.alert_id, om.alert_log_id, om.channel_id, om.contact_method_id, om.created_at, om.cycle_id, om.escalation_policy_id, om.fired_at, om.id, om.last_status, om.last_status_at, om.message_type, om.next_retry_at, om.provider_msg_id, om.provider_seq, om.retry_count, om.schedule_id, om.sending_deadline, om.sent_at, om.service_id, om.src_value, om.status_alert_ids, om.status_details, om.user_id, om.user_verification_code_id,
    cm.dest AS cm_dest,
    ch.dest AS ch_dest
FROM
    outgoing_messages om
    LEFT JOIN notification_channels ch ON om.channel_id = ch.id
    LEFT JOIN user_contact_methods cm ON om.contact_method_id = cm.id
WHERE
    om.id = ANY ($1::uuid[])
`

type NfyManyMessageStatusRow struct {
	OutgoingMessage OutgoingMessage
	CmDest          NullDestV1
	ChDest          NullDestV1
}

func (q *Queries) NfyManyMessageStatus(ctx context.Context, dollar_1 []uuid.UUID) ([]NfyManyMessageStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, nfyManyMessageStatus, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NfyManyMessageStatusRow
	for rows.Next() {
		var i NfyManyMessageStatusRow
		if err := rows.Scan(
			&i.OutgoingMessage.AlertID,
			&i.OutgoingMessage.AlertLogID,
			&i.OutgoingMessage.ChannelID,
			&i.OutgoingMessage.ContactMethodID,
			&i.OutgoingMessage.CreatedAt,
			&i.OutgoingMessage.CycleID,
			&i.OutgoingMessage.EscalationPolicyID,
			&i.OutgoingMessage.FiredAt,
			&i.OutgoingMessage.ID,
			&i.OutgoingMessage.LastStatus,
			&i.OutgoingMessage.LastStatusAt,
			&i.OutgoingMessage.MessageType,
			&i.OutgoingMessage.NextRetryAt,
			&i.OutgoingMessage.ProviderMsgID,
			&i.OutgoingMessage.ProviderSeq,
			&i.OutgoingMessage.RetryCount,
			&i.OutgoingMessage.ScheduleID,
			&i.OutgoingMessage.SendingDeadline,
			&i.OutgoingMessage.SentAt,
			&i.OutgoingMessage.ServiceID,
			&i.OutgoingMessage.SrcValue,
			pq.Array(&i.OutgoingMessage.StatusAlertIds),
			&i.OutgoingMessage.StatusDetails,
			&i.OutgoingMessage.UserID,
			&i.OutgoingMessage.UserVerificationCodeID,
			&i.CmDest,
			&i.ChDest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nfyOriginalMessageStatus = `-- name: NfyOriginalMessageStatus :one
SELECT
    om.alert_id, om.alert_log_id, om.channel_id, om.contact_method_id, om.created_at, om.cycle_id, om.escalation_policy_id, om.fired_at, om.id, om.last_status, om.last_status_at, om.message_type, om.next_retry_at, om.provider_msg_id, om.provider_seq, om.retry_count, om.schedule_id, om.sending_deadline, om.sent_at, om.service_id, om.src_value, om.status_alert_ids, om.status_details, om.user_id, om.user_verification_code_id,
    cm.dest AS cm_dest,
    ch.dest AS ch_dest
FROM
    outgoing_messages om
    LEFT JOIN notification_channels ch ON om.channel_id = ch.id
    LEFT JOIN user_contact_methods cm ON om.contact_method_id = cm.id
WHERE
    message_type = 'alert_notification'
    AND alert_id = $1
    AND (contact_method_id = $2
        OR channel_id = $3)
ORDER BY
    sent_at
LIMIT 1
`

type NfyOriginalMessageStatusParams struct {
	AlertID         sql.NullInt64
	ContactMethodID uuid.NullUUID
	ChannelID       uuid.NullUUID
}

type NfyOriginalMessageStatusRow struct {
	OutgoingMessage OutgoingMessage
	CmDest          NullDestV1
	ChDest          NullDestV1
}

func (q *Queries) NfyOriginalMessageStatus(ctx context.Context, arg NfyOriginalMessageStatusParams) (NfyOriginalMessageStatusRow, error) {
	row := q.db.QueryRowContext(ctx, nfyOriginalMessageStatus, arg.AlertID, arg.ContactMethodID, arg.ChannelID)
	var i NfyOriginalMessageStatusRow
	err := row.Scan(
		&i.OutgoingMessage.AlertID,
		&i.OutgoingMessage.AlertLogID,
		&i.OutgoingMessage.ChannelID,
		&i.OutgoingMessage.ContactMethodID,
		&i.OutgoingMessage.CreatedAt,
		&i.OutgoingMessage.CycleID,
		&i.OutgoingMessage.EscalationPolicyID,
		&i.OutgoingMessage.FiredAt,
		&i.OutgoingMessage.ID,
		&i.OutgoingMessage.LastStatus,
		&i.OutgoingMessage.LastStatusAt,
		&i.OutgoingMessage.MessageType,
		&i.OutgoingMessage.NextRetryAt,
		&i.OutgoingMessage.ProviderMsgID,
		&i.OutgoingMessage.ProviderSeq,
		&i.OutgoingMessage.RetryCount,
		&i.OutgoingMessage.ScheduleID,
		&i.OutgoingMessage.SendingDeadline,
		&i.OutgoingMessage.SentAt,
		&i.OutgoingMessage.ServiceID,
		&i.OutgoingMessage.SrcValue,
		pq.Array(&i.OutgoingMessage.StatusAlertIds),
		&i.OutgoingMessage.StatusDetails,
		&i.OutgoingMessage.UserID,
		&i.OutgoingMessage.UserVerificationCodeID,
		&i.CmDest,
		&i.ChDest,
	)
	return i, err
}

const noticeUnackedAlertsByService = `-- name: NoticeUnackedAlertsByService :one
SELECT
    count(*),
    (
        SELECT
            max
        FROM
            config_limits
        WHERE
            id = 'unacked_alerts_per_service'
    )
FROM
    alerts
WHERE
    service_id = $1::uuid
    AND status = 'triggered'
`

type NoticeUnackedAlertsByServiceRow struct {
	Count int64
	Max   int32
}

func (q *Queries) NoticeUnackedAlertsByService(ctx context.Context, dollar_1 uuid.UUID) (NoticeUnackedAlertsByServiceRow, error) {
	row := q.db.QueryRowContext(ctx, noticeUnackedAlertsByService, dollar_1)
	var i NoticeUnackedAlertsByServiceRow
	err := row.Scan(&i.Count, &i.Max)
	return i, err
}

const notifChanDeleteMany = `-- name: NotifChanDeleteMany :exec
DELETE FROM notification_channels
WHERE id = ANY ($1::uuid[])
`

func (q *Queries) NotifChanDeleteMany(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, notifChanDeleteMany, pq.Array(dollar_1))
	return err
}

const notifChanFindDestID = `-- name: NotifChanFindDestID :one
SELECT
    id
FROM
    notification_channels
WHERE
    dest = $1
`

func (q *Queries) NotifChanFindDestID(ctx context.Context, dest NullDestV1) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, notifChanFindDestID, dest)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const notifChanFindMany = `-- name: NotifChanFindMany :many
SELECT
    created_at, dest, id, meta, name, type, value
FROM
    notification_channels
WHERE
    id = ANY ($1::uuid[])
`

func (q *Queries) NotifChanFindMany(ctx context.Context, dollar_1 []uuid.UUID) ([]NotificationChannel, error) {
	rows, err := q.db.QueryContext(ctx, notifChanFindMany, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationChannel
	for rows.Next() {
		var i NotificationChannel
		if err := rows.Scan(
			&i.CreatedAt,
			&i.Dest,
			&i.ID,
			&i.Meta,
			&i.Name,
			&i.Type,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notifChanFindOne = `-- name: NotifChanFindOne :one
SELECT
    created_at, dest, id, meta, name, type, value
FROM
    notification_channels
WHERE
    id = $1
`

func (q *Queries) NotifChanFindOne(ctx context.Context, id uuid.UUID) (NotificationChannel, error) {
	row := q.db.QueryRowContext(ctx, notifChanFindOne, id)
	var i NotificationChannel
	err := row.Scan(
		&i.CreatedAt,
		&i.Dest,
		&i.ID,
		&i.Meta,
		&i.Name,
		&i.Type,
		&i.Value,
	)
	return i, err
}

const notifChanLock = `-- name: NotifChanLock :exec
LOCK notification_channels IN SHARE ROW EXCLUSIVE MODE
`

func (q *Queries) NotifChanLock(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, notifChanLock)
	return err
}

const notifChanUpsertDest = `-- name: NotifChanUpsertDest :one
INSERT INTO notification_channels(id, dest, name)
    VALUES ($1, $2, $3)
ON CONFLICT (dest)
    DO UPDATE SET
        name = $3
    RETURNING
        id
`

type NotifChanUpsertDestParams struct {
	ID   uuid.UUID
	Dest NullDestV1
	Name string
}

// NotifChanUpsertDest will insert a new destination if it does not exist, or updating it's name if it does.
func (q *Queries) NotifChanUpsertDest(ctx context.Context, arg NotifChanUpsertDestParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, notifChanUpsertDest, arg.ID, arg.Dest, arg.Name)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const now = `-- name: Now :one
SELECT now()::timestamptz
`

func (q *Queries) Now(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, now)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const overrideSearch = `-- name: OverrideSearch :many
WITH AFTER AS (
    SELECT
        id,
        start_time,
        end_time
    FROM
        user_overrides
    WHERE
        id = $8::uuid
)
SELECT
    o.id,
    o.start_time,
    o.end_time,
    add_user_id,
    remove_user_id,
    tgt_schedule_id
FROM
    user_overrides o
    LEFT JOIN AFTER ON TRUE
WHERE ($1::uuid[] ISNULL
    OR o.id <> ALL ($1))
AND ($2::uuid ISNULL
    OR o.tgt_schedule_id = $2)
AND ($3::uuid[] ISNULL
    OR add_user_id = ANY ($3::uuid[])
    OR remove_user_id = ANY ($3::uuid[]))
AND ($4::uuid[] ISNULL
    OR add_user_id = ANY ($4::uuid[]))
AND ($5::uuid[] ISNULL
    OR remove_user_id = ANY ($5::uuid[]))
AND (
    /* only include overrides that end after the search start */
    $6::timestamptz ISNULL
    OR o.end_time > $6)
AND (
    /* only include overrides that start before/within the search end */
    $7::timestamptz ISNULL
    OR o.start_time <= $7)
AND (
    /* resume search after specified "cursor" override */
    $8::uuid ISNULL
    OR (o.start_time > after.start_time
        OR (o.start_time = after.start_time
            AND o.end_time > after.end_time)
        OR (o.start_time = after.start_time
            AND o.end_time = after.end_time
            AND o.id > after.id)))
ORDER BY
    o.start_time,
    o.end_time,
    o.id
LIMIT 150
`

type OverrideSearchParams struct {
	Omit         []uuid.UUID
	ScheduleID   uuid.NullUUID
	AnyUserID    []uuid.UUID
	AddUserID    []uuid.UUID
	RemoveUserID []uuid.UUID
	SearchStart  sql.NullTime
	SearchEnd    sql.NullTime
	AfterID      uuid.NullUUID
}

type OverrideSearchRow struct {
	ID            uuid.UUID
	StartTime     time.Time
	EndTime       time.Time
	AddUserID     uuid.NullUUID
	RemoveUserID  uuid.NullUUID
	TgtScheduleID uuid.UUID
}

func (q *Queries) OverrideSearch(ctx context.Context, arg OverrideSearchParams) ([]OverrideSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, overrideSearch,
		pq.Array(arg.Omit),
		arg.ScheduleID,
		pq.Array(arg.AnyUserID),
		pq.Array(arg.AddUserID),
		pq.Array(arg.RemoveUserID),
		arg.SearchStart,
		arg.SearchEnd,
		arg.AfterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverrideSearchRow
	for rows.Next() {
		var i OverrideSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.StartTime,
			&i.EndTime,
			&i.AddUserID,
			&i.RemoveUserID,
			&i.TgtScheduleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const procAcquireModuleLock = `-- name: ProcAcquireModuleLock :one
SELECT
    version
FROM
    engine_processing_versions
WHERE
    type_id = $1
FOR UPDATE
    NOWAIT
`

func (q *Queries) ProcAcquireModuleLock(ctx context.Context, typeID EngineProcessingType) (int32, error) {
	row := q.db.QueryRowContext(ctx, procAcquireModuleLock, typeID)
	var version int32
	err := row.Scan(&version)
	return version, err
}

const procLoadState = `-- name: ProcLoadState :one
SELECT
    state
FROM
    engine_processing_versions
WHERE
    type_id = $1
`

func (q *Queries) ProcLoadState(ctx context.Context, typeID EngineProcessingType) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, procLoadState, typeID)
	var state json.RawMessage
	err := row.Scan(&state)
	return state, err
}

const procReadModuleVersion = `-- name: ProcReadModuleVersion :one
SELECT
    version
FROM
    engine_processing_versions
WHERE
    type_id = $1
`

func (q *Queries) ProcReadModuleVersion(ctx context.Context, typeID EngineProcessingType) (int32, error) {
	row := q.db.QueryRowContext(ctx, procReadModuleVersion, typeID)
	var version int32
	err := row.Scan(&version)
	return version, err
}

const procSaveState = `-- name: ProcSaveState :exec
UPDATE
    engine_processing_versions
SET
    state = $2
WHERE
    type_id = $1
`

type ProcSaveStateParams struct {
	TypeID EngineProcessingType
	State  json.RawMessage
}

func (q *Queries) ProcSaveState(ctx context.Context, arg ProcSaveStateParams) error {
	_, err := q.db.ExecContext(ctx, procSaveState, arg.TypeID, arg.State)
	return err
}

const procSharedAdvisoryLock = `-- name: ProcSharedAdvisoryLock :one
SELECT
    pg_try_advisory_xact_lock_shared($1) AS lock_acquired
`

func (q *Queries) ProcSharedAdvisoryLock(ctx context.Context, pgTryAdvisoryXactLockShared int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, procSharedAdvisoryLock, pgTryAdvisoryXactLockShared)
	var lock_acquired bool
	err := row.Scan(&lock_acquired)
	return lock_acquired, err
}

const requestAlertEscalationByTime = `-- name: RequestAlertEscalationByTime :one
UPDATE
    escalation_policy_state
SET
    force_escalation = TRUE
WHERE
    alert_id = $1
    AND (last_escalation <= $2::timestamptz
        OR last_escalation IS NULL)
RETURNING
    TRUE
`

type RequestAlertEscalationByTimeParams struct {
	AlertID int64
	Column2 time.Time
}

func (q *Queries) RequestAlertEscalationByTime(ctx context.Context, arg RequestAlertEscalationByTimeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, requestAlertEscalationByTime, arg.AlertID, arg.Column2)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const sWOConnLock = `-- name: SWOConnLock :one
WITH LOCK AS (
    SELECT
        pg_advisory_lock_shared(4369))
SELECT
    current_state = 'use_next_db'
FROM
    LOCK,
    switchover_state
`

func (q *Queries) SWOConnLock(ctx context.Context) (bool, error) {
	row := q.db.QueryRowContext(ctx, sWOConnLock)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const sWOConnUnlockAll = `-- name: SWOConnUnlockAll :exec
SELECT
    pg_advisory_unlock_all()
`

func (q *Queries) SWOConnUnlockAll(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, sWOConnUnlockAll)
	return err
}

const schedMgrDataForUpdate = `-- name: SchedMgrDataForUpdate :many
SELECT
    schedule_id,
    data
FROM
    schedule_data
WHERE
    data NOTNULL
FOR UPDATE
`

type SchedMgrDataForUpdateRow struct {
	ScheduleID uuid.UUID
	Data       json.RawMessage
}

func (q *Queries) SchedMgrDataForUpdate(ctx context.Context) ([]SchedMgrDataForUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrDataForUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchedMgrDataForUpdateRow
	for rows.Next() {
		var i SchedMgrDataForUpdateRow
		if err := rows.Scan(&i.ScheduleID, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schedMgrDataIDs = `-- name: SchedMgrDataIDs :many
SELECT
    schedule_id
FROM
    schedule_data
`

// Returns all schedule IDs that have an entry in the schedule_data table.
func (q *Queries) SchedMgrDataIDs(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrDataIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var schedule_id uuid.UUID
		if err := rows.Scan(&schedule_id); err != nil {
			return nil, err
		}
		items = append(items, schedule_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schedMgrEndOnCall = `-- name: SchedMgrEndOnCall :exec
UPDATE
    schedule_on_call_users
SET
    end_time = now()
WHERE
    schedule_id = $1
    AND user_id = $2
    AND end_time ISNULL
`

type SchedMgrEndOnCallParams struct {
	ScheduleID uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) SchedMgrEndOnCall(ctx context.Context, arg SchedMgrEndOnCallParams) error {
	_, err := q.db.ExecContext(ctx, schedMgrEndOnCall, arg.ScheduleID, arg.UserID)
	return err
}

const schedMgrGetData = `-- name: SchedMgrGetData :one
SELECT
    data
FROM
    schedule_data
WHERE
    schedule_id = $1
`

// Returns the data for a single schedule.
func (q *Queries) SchedMgrGetData(ctx context.Context, scheduleID uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, schedMgrGetData, scheduleID)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const schedMgrInsertMessage = `-- name: SchedMgrInsertMessage :exec
INSERT INTO outgoing_messages(id, message_type, channel_id, schedule_id)
    VALUES ($1, 'schedule_on_call_notification', $2, $3)
`

type SchedMgrInsertMessageParams struct {
	ID         uuid.UUID
	ChannelID  uuid.NullUUID
	ScheduleID uuid.NullUUID
}

func (q *Queries) SchedMgrInsertMessage(ctx context.Context, arg SchedMgrInsertMessageParams) error {
	_, err := q.db.ExecContext(ctx, schedMgrInsertMessage, arg.ID, arg.ChannelID, arg.ScheduleID)
	return err
}

const schedMgrNCDedupMapping = `-- name: SchedMgrNCDedupMapping :many
SELECT
    old_id,
    new_id
FROM
    notification_channel_duplicates
`

type SchedMgrNCDedupMappingRow struct {
	OldID uuid.UUID
	NewID uuid.UUID
}

// Returns the mapping of old notification channel IDs to new notification channel IDs.
func (q *Queries) SchedMgrNCDedupMapping(ctx context.Context) ([]SchedMgrNCDedupMappingRow, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrNCDedupMapping)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchedMgrNCDedupMappingRow
	for rows.Next() {
		var i SchedMgrNCDedupMappingRow
		if err := rows.Scan(&i.OldID, &i.NewID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schedMgrOnCall = `-- name: SchedMgrOnCall :many
SELECT
    schedule_id,
    user_id
FROM
    schedule_on_call_users
WHERE
    end_time ISNULL
`

type SchedMgrOnCallRow struct {
	ScheduleID uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) SchedMgrOnCall(ctx context.Context) ([]SchedMgrOnCallRow, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrOnCall)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchedMgrOnCallRow
	for rows.Next() {
		var i SchedMgrOnCallRow
		if err := rows.Scan(&i.ScheduleID, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schedMgrOverrides = `-- name: SchedMgrOverrides :many
SELECT
    add_user_id,
    remove_user_id,
    tgt_schedule_id
FROM
    user_overrides
WHERE
    now() BETWEEN start_time AND end_time
`

type SchedMgrOverridesRow struct {
	AddUserID     uuid.NullUUID
	RemoveUserID  uuid.NullUUID
	TgtScheduleID uuid.UUID
}

func (q *Queries) SchedMgrOverrides(ctx context.Context) ([]SchedMgrOverridesRow, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrOverrides)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchedMgrOverridesRow
	for rows.Next() {
		var i SchedMgrOverridesRow
		if err := rows.Scan(&i.AddUserID, &i.RemoveUserID, &i.TgtScheduleID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schedMgrRules = `-- name: SchedMgrRules :many
SELECT
    rule.created_at, rule.end_time, rule.friday, rule.id, rule.is_active, rule.monday, rule.saturday, rule.schedule_id, rule.start_time, rule.sunday, rule.tgt_rotation_id, rule.tgt_user_id, rule.thursday, rule.tuesday, rule.wednesday,
    coalesce(rule.tgt_user_id, part.user_id) AS resolved_user_id
FROM
    schedule_rules rule
    LEFT JOIN rotation_state rState ON rState.rotation_id = rule.tgt_rotation_id
    LEFT JOIN rotation_participants part ON part.id = rState.rotation_participant_id
WHERE
    coalesce(rule.tgt_user_id, part.user_id)
    NOTNULL
`

type SchedMgrRulesRow struct {
	CreatedAt      time.Time
	EndTime        timeutil.Clock
	Friday         bool
	ID             uuid.UUID
	IsActive       bool
	Monday         bool
	Saturday       bool
	ScheduleID     uuid.UUID
	StartTime      timeutil.Clock
	Sunday         bool
	TgtRotationID  uuid.NullUUID
	TgtUserID      uuid.NullUUID
	Thursday       bool
	Tuesday        bool
	Wednesday      bool
	ResolvedUserID uuid.UUID
}

func (q *Queries) SchedMgrRules(ctx context.Context) ([]SchedMgrRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchedMgrRulesRow
	for rows.Next() {
		var i SchedMgrRulesRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.EndTime,
			&i.Friday,
			&i.ID,
			&i.IsActive,
			&i.Monday,
			&i.Saturday,
			&i.ScheduleID,
			&i.StartTime,
			&i.Sunday,
			&i.TgtRotationID,
			&i.TgtUserID,
			&i.Thursday,
			&i.Tuesday,
			&i.Wednesday,
			&i.ResolvedUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schedMgrSetData = `-- name: SchedMgrSetData :exec
UPDATE
    schedule_data
SET
    data = $2
WHERE
    schedule_id = $1
`

type SchedMgrSetDataParams struct {
	ScheduleID uuid.UUID
	Data       json.RawMessage
}

func (q *Queries) SchedMgrSetData(ctx context.Context, arg SchedMgrSetDataParams) error {
	_, err := q.db.ExecContext(ctx, schedMgrSetData, arg.ScheduleID, arg.Data)
	return err
}

const schedMgrSetDataV1Rules = `-- name: SchedMgrSetDataV1Rules :exec
UPDATE
    schedule_data
SET
    data = jsonb_set(data, '{V1,OnCallNotificationRules}', $2)
WHERE
    schedule_id = $1
`

type SchedMgrSetDataV1RulesParams struct {
	ScheduleID  uuid.UUID
	Replacement json.RawMessage
}

// Sets the .V1.OnCallNotificationRules for a schedule.
func (q *Queries) SchedMgrSetDataV1Rules(ctx context.Context, arg SchedMgrSetDataV1RulesParams) error {
	_, err := q.db.ExecContext(ctx, schedMgrSetDataV1Rules, arg.ScheduleID, arg.Replacement)
	return err
}

const schedMgrStartOnCall = `-- name: SchedMgrStartOnCall :exec
INSERT INTO schedule_on_call_users(schedule_id, start_time, user_id)
SELECT
    $1,
    now(),
    $2
FROM
    users
WHERE
    id = $2
`

type SchedMgrStartOnCallParams struct {
	ScheduleID uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) SchedMgrStartOnCall(ctx context.Context, arg SchedMgrStartOnCallParams) error {
	_, err := q.db.ExecContext(ctx, schedMgrStartOnCall, arg.ScheduleID, arg.UserID)
	return err
}

const schedMgrTimezones = `-- name: SchedMgrTimezones :many
SELECT
    id,
    time_zone
FROM
    schedules
`

type SchedMgrTimezonesRow struct {
	ID       uuid.UUID
	TimeZone string
}

func (q *Queries) SchedMgrTimezones(ctx context.Context) ([]SchedMgrTimezonesRow, error) {
	rows, err := q.db.QueryContext(ctx, schedMgrTimezones)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchedMgrTimezonesRow
	for rows.Next() {
		var i SchedMgrTimezonesRow
		if err := rows.Scan(&i.ID, &i.TimeZone); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleFindManyByUser = `-- name: ScheduleFindManyByUser :many
SELECT
    description, id, last_processed, name, time_zone
FROM
    schedules
WHERE
    id = ANY (
        SELECT
            schedule_id
        FROM
            schedule_rules
        WHERE
            tgt_user_id = $1
            OR tgt_rotation_id = ANY (
                SELECT
                    rotation_id
                FROM
                    rotation_participants
                WHERE
                    user_id = $1))
`

func (q *Queries) ScheduleFindManyByUser(ctx context.Context, tgtUserID uuid.NullUUID) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, scheduleFindManyByUser, tgtUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.Description,
			&i.ID,
			&i.LastProcessed,
			&i.Name,
			&i.TimeZone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sequenceNames = `-- name: SequenceNames :many
SELECT sequence_name::text
FROM information_schema.sequences
WHERE sequence_catalog = current_database()
    AND sequence_schema = 'public'
    AND sequence_name != 'change_log_id_seq'
`

func (q *Queries) SequenceNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, sequenceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var sequence_name string
		if err := rows.Scan(&sequence_name); err != nil {
			return nil, err
		}
		items = append(items, sequence_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAlertFeedback = `-- name: SetAlertFeedback :exec
INSERT INTO alert_feedback(alert_id, noise_reason)
    VALUES ($1, $2)
ON CONFLICT (alert_id)
    DO UPDATE SET
        noise_reason = $2
    WHERE
        alert_feedback.alert_id = $1
`

type SetAlertFeedbackParams struct {
	AlertID     int64
	NoiseReason string
}

func (q *Queries) SetAlertFeedback(ctx context.Context, arg SetAlertFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, setAlertFeedback, arg.AlertID, arg.NoiseReason)
	return err
}

const setManyAlertFeedback = `-- name: SetManyAlertFeedback :many
INSERT INTO alert_feedback(alert_id, noise_reason)
    VALUES (unnest($1::bigint[]), $2)
ON CONFLICT (alert_id)
    DO UPDATE SET
        noise_reason = excluded.noise_reason
    WHERE
        alert_feedback.alert_id = excluded.alert_id
    RETURNING
        alert_id
`

type SetManyAlertFeedbackParams struct {
	AlertIds    []int64
	NoiseReason string
}

func (q *Queries) SetManyAlertFeedback(ctx context.Context, arg SetManyAlertFeedbackParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, setManyAlertFeedback, pq.Array(arg.AlertIds), arg.NoiseReason)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var alert_id int64
		if err := rows.Scan(&alert_id); err != nil {
			return nil, err
		}
		items = append(items, alert_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signalMgrDeleteStale = `-- name: SignalMgrDeleteStale :exec
DELETE FROM pending_signals
WHERE message_id IS NULL
    AND created_at < NOW() - INTERVAL '1 hour'
`

// Delete stale pending signals.
func (q *Queries) SignalMgrDeleteStale(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, signalMgrDeleteStale)
	return err
}

const signalMgrGetPending = `-- name: SignalMgrGetPending :many
SELECT
    id,
    dest_id,
    service_id
FROM
    pending_signals
WHERE
    message_id IS NULL
    AND ($1::uuid IS NULL
        OR service_id = $1)
FOR UPDATE
    SKIP LOCKED
LIMIT 100
`

type SignalMgrGetPendingRow struct {
	ID        int32
	DestID    uuid.UUID
	ServiceID uuid.UUID
}

// Get a batch of pending signals to process.
func (q *Queries) SignalMgrGetPending(ctx context.Context, serviceID uuid.NullUUID) ([]SignalMgrGetPendingRow, error) {
	rows, err := q.db.QueryContext(ctx, signalMgrGetPending, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SignalMgrGetPendingRow
	for rows.Next() {
		var i SignalMgrGetPendingRow
		if err := rows.Scan(&i.ID, &i.DestID, &i.ServiceID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signalMgrGetScheduled = `-- name: SignalMgrGetScheduled :many
SELECT
    count(*),
    service_id,
    channel_id
FROM
    outgoing_messages
WHERE
    message_type = 'signal_message'
    AND last_status = 'pending'
    AND ($1::uuid IS NULL
        OR service_id = $1)
GROUP BY
    service_id,
    channel_id
`

type SignalMgrGetScheduledRow struct {
	Count     int64
	ServiceID uuid.NullUUID
	ChannelID uuid.NullUUID
}

func (q *Queries) SignalMgrGetScheduled(ctx context.Context, serviceID uuid.NullUUID) ([]SignalMgrGetScheduledRow, error) {
	rows, err := q.db.QueryContext(ctx, signalMgrGetScheduled, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SignalMgrGetScheduledRow
	for rows.Next() {
		var i SignalMgrGetScheduledRow
		if err := rows.Scan(&i.Count, &i.ServiceID, &i.ChannelID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const signalMgrInsertMessage = `-- name: SignalMgrInsertMessage :exec
INSERT INTO outgoing_messages(id, message_type, service_id, channel_id)
    VALUES ($1, 'signal_message', $2, $3)
`

type SignalMgrInsertMessageParams struct {
	ID        uuid.UUID
	ServiceID uuid.NullUUID
	ChannelID uuid.NullUUID
}

// Insert a new message into the outgoing_messages table.
func (q *Queries) SignalMgrInsertMessage(ctx context.Context, arg SignalMgrInsertMessageParams) error {
	_, err := q.db.ExecContext(ctx, signalMgrInsertMessage, arg.ID, arg.ServiceID, arg.ChannelID)
	return err
}

const signalMgrUpdateSignal = `-- name: SignalMgrUpdateSignal :exec
UPDATE
    pending_signals
SET
    message_id = $2
WHERE
    id = $1
`

type SignalMgrUpdateSignalParams struct {
	ID        int32
	MessageID uuid.NullUUID
}

// Update a pending signal with the message_id.
func (q *Queries) SignalMgrUpdateSignal(ctx context.Context, arg SignalMgrUpdateSignalParams) error {
	_, err := q.db.ExecContext(ctx, signalMgrUpdateSignal, arg.ID, arg.MessageID)
	return err
}

const statusMgrCMInfo = `-- name: StatusMgrCMInfo :one
SELECT
    user_id,
    dest
FROM
    user_contact_methods
WHERE
    id = $1
    AND NOT disabled
    AND enable_status_updates
`

type StatusMgrCMInfoRow struct {
	UserID uuid.UUID
	Dest   NullDestV1
}

func (q *Queries) StatusMgrCMInfo(ctx context.Context, id uuid.UUID) (StatusMgrCMInfoRow, error) {
	row := q.db.QueryRowContext(ctx, statusMgrCMInfo, id)
	var i StatusMgrCMInfoRow
	err := row.Scan(&i.UserID, &i.Dest)
	return i, err
}

const statusMgrCleanupDisabledSubs = `-- name: StatusMgrCleanupDisabledSubs :exec
DELETE FROM alert_status_subscriptions sub USING user_contact_methods cm
WHERE sub.contact_method_id = cm.id
    AND (cm.disabled
        OR NOT cm.enable_status_updates)
`

func (q *Queries) StatusMgrCleanupDisabledSubs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, statusMgrCleanupDisabledSubs)
	return err
}

const statusMgrCleanupStaleSubs = `-- name: StatusMgrCleanupStaleSubs :exec
DELETE FROM alert_status_subscriptions sub
WHERE sub.updated_at < now() - '7 days'::interval
`

func (q *Queries) StatusMgrCleanupStaleSubs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, statusMgrCleanupStaleSubs)
	return err
}

const statusMgrDeleteSub = `-- name: StatusMgrDeleteSub :exec
DELETE FROM alert_status_subscriptions
WHERE id = $1
`

func (q *Queries) StatusMgrDeleteSub(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, statusMgrDeleteSub, id)
	return err
}

const statusMgrLogEntry = `-- name: StatusMgrLogEntry :one
SELECT
    id,
    sub_user_id AS user_id
FROM
    alert_logs
WHERE
    alert_id = $1::bigint
    AND event = $2::enum_alert_log_event
    AND timestamp > now() - '1 hour'::interval
ORDER BY
    id DESC
LIMIT 1
`

type StatusMgrLogEntryParams struct {
	AlertID   int64
	EventType EnumAlertLogEvent
}

type StatusMgrLogEntryRow struct {
	ID     int64
	UserID uuid.NullUUID
}

func (q *Queries) StatusMgrLogEntry(ctx context.Context, arg StatusMgrLogEntryParams) (StatusMgrLogEntryRow, error) {
	row := q.db.QueryRowContext(ctx, statusMgrLogEntry, arg.AlertID, arg.EventType)
	var i StatusMgrLogEntryRow
	err := row.Scan(&i.ID, &i.UserID)
	return i, err
}

const statusMgrNextUpdate = `-- name: StatusMgrNextUpdate :one
SELECT
    sub.id,
    channel_id,
    contact_method_id,
    alert_id,
(
        SELECT
            status
        FROM
            alerts a
        WHERE
            a.id = sub.alert_id)
FROM
    alert_status_subscriptions sub
WHERE (NOT (sub.id = ANY ($1::bigint[])))
    AND sub.last_alert_status !=(
        SELECT
            status
        FROM
            alerts a
        WHERE
            a.id = sub.alert_id)
LIMIT 1
FOR UPDATE
    SKIP LOCKED
`

type StatusMgrNextUpdateRow struct {
	ID              int64
	ChannelID       uuid.NullUUID
	ContactMethodID uuid.NullUUID
	AlertID         int64
	Status          EnumAlertStatus
}

func (q *Queries) StatusMgrNextUpdate(ctx context.Context, dollar_1 []int64) (StatusMgrNextUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, statusMgrNextUpdate, pq.Array(dollar_1))
	var i StatusMgrNextUpdateRow
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ContactMethodID,
		&i.AlertID,
		&i.Status,
	)
	return i, err
}

const statusMgrSendChannelMsg = `-- name: StatusMgrSendChannelMsg :exec
INSERT INTO outgoing_messages(id, message_type, channel_id, alert_id, alert_log_id)
    VALUES ($1::uuid, 'alert_status_update', $2::uuid, $3::bigint, $4)
`

type StatusMgrSendChannelMsgParams struct {
	ID        uuid.UUID
	ChannelID uuid.UUID
	AlertID   int64
	LogID     sql.NullInt64
}

func (q *Queries) StatusMgrSendChannelMsg(ctx context.Context, arg StatusMgrSendChannelMsgParams) error {
	_, err := q.db.ExecContext(ctx, statusMgrSendChannelMsg,
		arg.ID,
		arg.ChannelID,
		arg.AlertID,
		arg.LogID,
	)
	return err
}

const statusMgrSendUserMsg = `-- name: StatusMgrSendUserMsg :exec
INSERT INTO outgoing_messages(id, message_type, contact_method_id, user_id, alert_id, alert_log_id)
    VALUES ($1::uuid, 'alert_status_update', $2::uuid, $3::uuid, $4::bigint, $5)
`

type StatusMgrSendUserMsgParams struct {
	ID      uuid.UUID
	CmID    uuid.UUID
	UserID  uuid.UUID
	AlertID int64
	LogID   sql.NullInt64
}

func (q *Queries) StatusMgrSendUserMsg(ctx context.Context, arg StatusMgrSendUserMsgParams) error {
	_, err := q.db.ExecContext(ctx, statusMgrSendUserMsg,
		arg.ID,
		arg.CmID,
		arg.UserID,
		arg.AlertID,
		arg.LogID,
	)
	return err
}

const statusMgrUpdateCMForced = `-- name: StatusMgrUpdateCMForced :exec
UPDATE
    user_contact_methods
SET
    enable_status_updates = TRUE
WHERE
    dest ->> 'Type' = ANY ($1::text[])
    AND NOT enable_status_updates
`

func (q *Queries) StatusMgrUpdateCMForced(ctx context.Context, forcedDestTypes []string) error {
	_, err := q.db.ExecContext(ctx, statusMgrUpdateCMForced, pq.Array(forcedDestTypes))
	return err
}

const statusMgrUpdateSub = `-- name: StatusMgrUpdateSub :exec
UPDATE
    alert_status_subscriptions
SET
    last_alert_status = $2,
    updated_at = now()
WHERE
    id = $1
`

type StatusMgrUpdateSubParams struct {
	ID              int64
	LastAlertStatus EnumAlertStatus
}

func (q *Queries) StatusMgrUpdateSub(ctx context.Context, arg StatusMgrUpdateSubParams) error {
	_, err := q.db.ExecContext(ctx, statusMgrUpdateSub, arg.ID, arg.LastAlertStatus)
	return err
}

const tableColumns = `-- name: TableColumns :many
SELECT col.table_name::text,
    col.column_name::text,
    col.data_type::text,
    col.ordinal_position::INT
FROM information_schema.columns col
    JOIN information_schema.tables t ON t.table_catalog = col.table_catalog
    AND t.table_schema = col.table_schema
    AND t.table_name = col.table_name
    AND t.table_type = 'BASE TABLE'
WHERE col.table_catalog = current_database()
    AND col.table_schema = 'public'
`

type TableColumnsRow struct {
	ColTableName       string
	ColColumnName      string
	ColDataType        string
	ColOrdinalPosition int32
}

func (q *Queries) TableColumns(ctx context.Context) ([]TableColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, tableColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TableColumnsRow
	for rows.Next() {
		var i TableColumnsRow
		if err := rows.Scan(
			&i.ColTableName,
			&i.ColColumnName,
			&i.ColDataType,
			&i.ColOrdinalPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCalSub = `-- name: UpdateCalSub :exec
UPDATE
    user_calendar_subscriptions
SET
    NAME = $1,
    disabled = $2,
    config = $3,
    last_update = now()
WHERE
    id = $4
    AND user_id = $5
`

type UpdateCalSubParams struct {
	Name     string
	Disabled bool
	Config   json.RawMessage
	ID       uuid.UUID
	UserID   uuid.UUID
}

func (q *Queries) UpdateCalSub(ctx context.Context, arg UpdateCalSubParams) error {
	_, err := q.db.ExecContext(ctx, updateCalSub,
		arg.Name,
		arg.Disabled,
		arg.Config,
		arg.ID,
		arg.UserID,
	)
	return err
}

const userFavFindAll = `-- name: UserFavFindAll :many
SELECT
    tgt_service_id,
    tgt_schedule_id,
    tgt_rotation_id,
    tgt_escalation_policy_id,
    tgt_user_id
FROM
    user_favorites
WHERE
    user_id = $1
    AND ((tgt_service_id NOTNULL
            AND $2::bool)
        OR (tgt_schedule_id NOTNULL
            AND $3::bool)
        OR (tgt_rotation_id NOTNULL
            AND $4::bool)
        OR (tgt_escalation_policy_id NOTNULL
            AND $5::bool)
        OR (tgt_user_id NOTNULL
            AND $6::bool))
`

type UserFavFindAllParams struct {
	UserID                  uuid.UUID
	AllowServices           bool
	AllowSchedules          bool
	AllowRotations          bool
	AllowEscalationPolicies bool
	AllowUsers              bool
}

type UserFavFindAllRow struct {
	TgtServiceID          uuid.NullUUID
	TgtScheduleID         uuid.NullUUID
	TgtRotationID         uuid.NullUUID
	TgtEscalationPolicyID uuid.NullUUID
	TgtUserID             uuid.NullUUID
}

func (q *Queries) UserFavFindAll(ctx context.Context, arg UserFavFindAllParams) ([]UserFavFindAllRow, error) {
	rows, err := q.db.QueryContext(ctx, userFavFindAll,
		arg.UserID,
		arg.AllowServices,
		arg.AllowSchedules,
		arg.AllowRotations,
		arg.AllowEscalationPolicies,
		arg.AllowUsers,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFavFindAllRow
	for rows.Next() {
		var i UserFavFindAllRow
		if err := rows.Scan(
			&i.TgtServiceID,
			&i.TgtScheduleID,
			&i.TgtRotationID,
			&i.TgtEscalationPolicyID,
			&i.TgtUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFavSet = `-- name: UserFavSet :exec
INSERT INTO user_favorites(user_id, tgt_service_id, tgt_schedule_id, tgt_rotation_id, tgt_escalation_policy_id, tgt_user_id)
    VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT
    DO NOTHING
`

type UserFavSetParams struct {
	UserID                uuid.UUID
	TgtServiceID          uuid.NullUUID
	TgtScheduleID         uuid.NullUUID
	TgtRotationID         uuid.NullUUID
	TgtEscalationPolicyID uuid.NullUUID
	TgtUserID             uuid.NullUUID
}

func (q *Queries) UserFavSet(ctx context.Context, arg UserFavSetParams) error {
	_, err := q.db.ExecContext(ctx, userFavSet,
		arg.UserID,
		arg.TgtServiceID,
		arg.TgtScheduleID,
		arg.TgtRotationID,
		arg.TgtEscalationPolicyID,
		arg.TgtUserID,
	)
	return err
}

const userFavUnset = `-- name: UserFavUnset :exec
DELETE FROM user_favorites
WHERE user_id = $1
    AND tgt_service_id = $2
    OR tgt_schedule_id = $3
    OR tgt_rotation_id = $4
    OR tgt_escalation_policy_id = $5
    OR tgt_user_id = $6
`

type UserFavUnsetParams struct {
	UserID                uuid.UUID
	TgtServiceID          uuid.NullUUID
	TgtScheduleID         uuid.NullUUID
	TgtRotationID         uuid.NullUUID
	TgtEscalationPolicyID uuid.NullUUID
	TgtUserID             uuid.NullUUID
}

func (q *Queries) UserFavUnset(ctx context.Context, arg UserFavUnsetParams) error {
	_, err := q.db.ExecContext(ctx, userFavUnset,
		arg.UserID,
		arg.TgtServiceID,
		arg.TgtScheduleID,
		arg.TgtRotationID,
		arg.TgtEscalationPolicyID,
		arg.TgtUserID,
	)
	return err
}
